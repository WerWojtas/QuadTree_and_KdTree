\documentclass{lab}

\usepackage[utf8]{inputenc}
\usepackage{graphicx}
\usepackage{tocloft}
\usepackage{amssymb}
\usepackage{xcolor}
\usepackage{enumitem}
\usepackage{amsmath} 
\usepackage{animate}
\usepackage{graphicx}
\usepackage[T1]{fontenc} 
\usepackage[top=0.5in, bottom=0.5in, left=0.5in, right=0.5in]{geometry}
\usepackage{mathrsfs}
\usepackage{hyperref}
\usepackage{wrapfig}
\usepackage{indentfirst}
\usepackage{mathtools}
\usepackage[export]{adjustbox}
\usepackage{scrextend}
\usepackage{animate}
\usepackage{float}
\newcommand\tab[1][1cm]{\hspace*{#1}}
\geometry{
    margin=0.5in,
    left=2.2cm,
    right=2.2cm,
    headheight=17pt,
    headsep=1cm, % Increase the margin from the top for the header
    includehead,
    includefoot
}

% python color
\usepackage{listings}
\usepackage{xcolor}
\usepackage{caption}

% Define VSC Dark+ colors
\definecolor{vscode-background}{rgb}{0.0, 0.0, 0.0}
\definecolor{vscode-foreground}{rgb}{0.96, 0.96, 0.96}
\definecolor{vscode-comment}{rgb}{0.51, 0.51, 0.51}
\definecolor{vscode-orange}{rgb}{1.0, 0.6, 0.0}
\definecolor{vscode-yellow}{rgb}{0.98, 0.83, 0.26}
\definecolor{vscode-green}{rgb}{0.19, 0.8, 0.35}
\definecolor{vscode-cyan}{rgb}{0.16, 0.71, 0.73}
\definecolor{vscode-blue}{rgb}{0.13, 0.48, 0.78}
\definecolor{vscode-purple}{rgb}{0.58, 0.4, 0.72}
\definecolor{vscode-pink}{rgb}{0.8, 0.36, 0.36}

% Define the style
\lstdefinestyle{vscode-darkplus-python}{
    language=Python,
    backgroundcolor=\color{vscode-background},
    basicstyle=\color{vscode-foreground}\ttfamily\small,
    commentstyle=\color{vscode-comment},
    keywordstyle=\color{vscode-orange},
    numberstyle=\tiny\color{vscode-comment},
    numbers=left,
    stringstyle=\color{vscode-green},
    emphstyle=\color{vscode-pink},
    frame=none,
}
% Change the caption label to "Kod źródłowy"
\DeclareCaptionLabelFormat{myformat}{Kod źródłowy #2}

\usepackage[T1]{fontenc}
\usepackage[polish]{babel}
\usepackage[utf8]{inputenc}
\usepackage{amsmath}
\usepackage{listings}
\usepackage{hyperref}
\usepackage{pythonhighlight}
\usepackage{amssymb}
\usepackage{mathtools}
\usepackage{array}
\usepackage{xpatch}

\xpretocmd{\part}{\setcounter{section}{0}}{}{}
\usepackage[margin=0.5in,
    left=2.2cm,
    right=2.2cm,
    headheight=17pt,
    includehead, includefoot]{geometry}
    
%% nagłówek
\usepackage{fancyhdr}
\usepackage{tikz}
\usepackage{pgfplots}
\usepackage{pgfplotstable}
\pagestyle{fancy}
\fancyhf{}
\rhead{Algorytmy Geometryczne}
\lhead{Wyszukiwanie geometryczne}
\rfoot{\thepage}

%% Podmiana \part na obecne wyświetlanie
\makeatletter
\renewcommand\@part[2][]{%
  \ifnum \c@secnumdepth >-2\relax
    \refstepcounter{part}%
    \addcontentsline{toc}{part}{\thepart#2}%
  \else
    \addcontentsline{toc}{part}{#2}%
  \fi
  \markboth{}{}%
  {\raggedright % Align title to the left
   \interlinepenalty \@M
   \normalfont
   \ifnum \c@secnumdepth >-2\relax
     \Large\bfseries \thepart\hspace{1em}%
   \fi
   \huge \bfseries #2\par}%
  \@endpart
}
\makeatother

\renewcommand\thepart{\Roman{part}. }

\addtokomafont{labelinglabel}{\sffamily}

\renewcommand{\cftsecleader}{\cftdotfill{\cftdotsep}}
\renewcommand{\cftsubsecleader}{\cftdotfill{\cftdotsep}}


\begin{document}
\captionsetup[lstlisting]{labelformat=myformat}

\begin{figure*}
    \centering
    \includegraphics{resources/agh.png}
\end{figure*}
\title{\Huge \textbf{Wyszukiwanie Geometryczne}\\QuadTree i KdTree \\ \huge Dokumentacja}
\author{Weronika Wojtas, Radosław Rolka\\Algorytmy geometryczne\\Informatyka WI AGH, II rok}
\date{2023}

\maketitle
\newpage
\tableofcontents
\thispagestyle{fancy} 
\newpage

\part{Wstęp}
\section{Informacje wstępne}
Celem tej dokumentacji jest przedstawienie zaawansowanych technik wyszukiwania geometrycznego, z naciskiem na implementację i zastosowanie KdTree oraz QuadTree oraz ich porównanie.

Projekt został zaimplementowany w języku Python 3.9 z wykorzystaniem aplikacji Jupyter Notebook. Kod źródłowy wraz z dokumentacją zamieszczony jest w repozytorium GitHub.

\section{Wymagania techniczne}
\begin{itemize}
    \item python >= 3.9
    \item numpy >= 1.25.2
    \item pandas >= 2.0.3
    \item matplotlib >= 3.7.2
    \item notebook >= 6.5.4
    \item unittest (Python Standard Library)
    \item functools (Python Standard Library)
    \item math (Python Standard Library)
    \item copy (Python Standard Library)
\end{itemize}

\section{Środowisko wykonawcze}
\begin{table}[h]
\centering
\begin{tabular}{|c|c|c|}
\hline
 & Komputer 1 & Komputer 2 \\
\hline
Procesor & Intel(R) Core(TM) I5-10300H 2.50GHz & Intel(R) Core(TM) I3-1115G4 3.00GHz \\
\hline
System operacyjny & Microsoft Windows 10 64bit ver 22H2 & Microsoft Windows 11 Home 64bit ver 22H2 \\
\hline
\end{tabular}
\caption{Dane techniczne maszyn wykonawczych}
\end{table}
Porównanie efektywności struktur zostało wykonane na Komputerze 1.
\section{Zawarość programu}
Program składa się z następujących plików:
\begin{itemize}
    \item KdTree.py
    \item QuadTree.py
    \item TestManager.py
    \item Comparision.ipynb
    \item visualizer/
    \item utilities/
    \item tests/
    \item documentation/
    \item comparator/
\end{itemize}

\part{Dokumentacja}
W tym rozdziale znajduje się szczegółowa dokumentacja poszczególnych modułów programu, które są przewidziane do wykorzystania przez użytkownika. Klasy oraz metody, które nie są wymienione w tej dokumentacji, nie są przewidziane do bezpośredniego użycia.
\section{Utilities}
Ten moduł zapewnia podstawowe klasy elementów geometrycznych: punkt (Point) i prostokąt (Rectangle), które unifikują dane wejściowe do obu implementacji drzew oraz zapewniają walidację wprowadzonych danych.
\subsection{Point}
Reprezentacja niemutowalnego punktu o dodatniej liczbie wymiarów wraz z licznymi możliwościami wykorzystania i przetwarzania.
\begin{itemize}
    \item \textbf{Point(point)}: 
    Konstruktor punktu przyjmuje iterowalny obiekt jako argument i zapisuje jego wartości jako kolejne wymiary dla punktu.

    - point: iterowalny obiekt, którego wartości zostaną zapisane jako kolejne wymiary punktu.

    - RESULT: punkt zawierający wartości z point.
    
    Wywołuje ValueError("Point must have at least one dimension") jeśli obiekt jest pusty.
    \item \textbf{\_\_eq\_\_(self, other)}:
    Porównuje punkty na podstawie ich wymiarów, zwraca True jeśli wymiary są równe, w przeciwnym wypadku False. Umożliwia porównywanie punktów oraz innych iterowalnch struktur za pomocą operatorów == i !=.

    - other: punkt lub inny iterowalny obiekt, który zostanie porównany z punktem.

    - RESULT: True jeśli wymiary punktów są równe, False w przeciwnym wypadku.
    \item \textbf{\_\_hash\_\_(self)}:
    Zwraca hash punktu, umożliwiając jego użycie jako klucza w słownikach.

    - RESULT: hash punktu.
    \item \textbf{\_\_str\_\_(self) / \_\_repr\_\_(self)}:
    Zwraca string reprezentujący punkt w postaci (x1, x2, ..., xn), gdzie xi to kolejne wymiary punktu. Umożliwia wyświetlanie punktu za pomocą funkcji print().

    - RESULT: string reprezentujący punkt w postaci (x1, x2, ..., xn).

    \item \textbf{\_\_len\_\_(self)}:
    Zwraca liczbę wymiarów punktu.

    - RESULT: liczba wymiarów punktu.

    \item \textbf{\_\_getitem\_\_(self, key)}:
    Zwraca wymiar o indeksie key, umożliwiając dostęp do wymiarów punktu za pomocą operatora nawiasów kwadratowych.

    - key: indeks wymiaru.

    - RESULT: wymiar o indeksie key.
    \item \textbf{point(self)}:
    @property Zwraca listę zawierającą kopię wymiarów punktu.

    \item \textbf{x(self)}
    @property Zwraca pierwszy wymiar punktu.

    \item \textbf{y(self)}:
    @property Zwraca drugi wymiar punktu, jeśli istnieje.

    \item \textbf{follows(self, other)}:
    Porównuje punkty na podstawie ich wymiarów, zwraca True jeśli punkt jest mniejszy od other w każdym wymiarze, w przeciwnym wypadku False. Zezwala na porównywanie obiektów iterowalnych.

    - other: punkt lub inny iterowalny obiekt, który zostanie porównany z punktem.

    - RESULT: True jeśli punkt jest większy od other w każdym wymiarze, False w przeciwnym wypadku.

    Wywołuje ValueError("Can only compare Points of the same dimensionality") jeśli wymiary punktów nie są równe.

    \item \textbf{precedes(self, other)}:
    Porównuje punkty na podstawie ich wymiarów, zwraca True jeśli punkt jest większy od other w każdym wymiarze, w przeciwnym wypadku False. Zezwala na porównywanie obiektów iterowalnych.

    - other: punkt lub inny iterowalny obiekt, który zostanie porównany z punktem.

    - RESULT: True jeśli punkt jest większy od other w każdym wymiarze, False w przeciwnym wypadku.

    Wywołuje ValueError("Can only compare Points of the same dimensionality") jeśli wymiary punktów nie są równe.

    \item \textbf{distance(self, other)}:
    Oblicza odległość między punktami. Zezwala na porównywanie obiektów iterowalnych.

    - other: punkt lub inny iterowalny obiekt, od którego zostanie obliczona odległość.

    - RESULT: odległość między punktami.

    Wywołuje ValueError("Can only compare Points of the same dimensionality") jeśli wymiary punktów nie są równe.

    \item \textbf{minimum(self, other)}:
    Wyznacza punkt zawierający najmniejsze wartości z obu punktów. Zezwala na porównywanie obiektów iterowalnych.

    - other: punkt lub inny iterowalny obiekt, z którym zostanie wyznaczony punkt zawierający najmniejsze wartości.

    - RESULT: punkt zawierający najmniejsze wartości z obu punktów.

    Wywołuje ValueError("Can only compare Points of the same dimensionality") jeśli wymiary punktów nie są równe.

    \item \textbf{maximum(self, other)}:
    Wyznacza punkt zawierający największe wartości z obu punktów. Zezwala na porównywanie obiektów iterowalnych.

    - other: punkt lub inny iterowalny obiekt, z którym zostanie wyznaczony punkt zawierający największe wartości.

    - RESULT: punkt zawierający największe wartości z obu punktów.
    
    Wywołuje ValueError("Can only compare Points of the same dimensionality") jeśli wymiary punktów nie są równe.    
\end{itemize}

\subsection{Rectangle}
Reprezentacja niemutowalnego prostokąta o dodatniej liczbie wymiarów, zapisanego jako dwa przeciwległe wierzchołki: lewy dolny (lowerleft) i prawy górny (upperright).
\begin{itemize}
  \item \textbf{Rectangle(lowerleft, upperright)}:
  Konstruktor prostokąta przyjmuje dwa punkty (lub obiekty iterowalne) jako argumenty i zapisuje je jako przeciwległe wierzchołki prostokąta.

  - lowerleft: punkt (lub obiekt iterowalny), który zostanie zapisany jako lewy dolny wierzchołek prostokąta.

  - upperright: punkt (lub obiekt iterowalny), który zostanie zapisany jako prawy górny wierzchołek prostokąta.

  - RESULT: prostokąt zawierający punkty lowerleft i upperright.

  Wywołuje ValueError("Points must have the same dimensionality") jeśli wymiary punktów nie są równe.

  Wywołuje ValueError("LowerLeft point must precede the UpperRight point") jeśli któryś z wymiarów punktu lowerleft jest większy niż odpowiadający mu wymiar punktu upperright.

  \item \textbf{\_\_eq\_\_(self, other)}:
  Porównuje prostokąty na podstawie ich wierzchołków, zwraca True jeśli wierzchołki są równe, w przeciwnym wypadku False. Umożliwia porównywanie za pomocą operatorów == i !=.

  - other: dowolny obiekt, który zostanie porównany z prostokątem.

  - RESULT: True jeśli wierzchołki prostokątów są równe, False w przeciwnym wypadku.
  \item \textbf{\_\_hash\_\_(self)}:
  Zwraca hash prostokąta, umożliwiając jego użycie jako klucza w słownikach.

  - RESULT: hash prostokąta.

  \item \textbf{\_\_str\_\_(self) / \_\_repr\_\_(self)}:
  Zwraca string reprezentujący prostokąt w postaci [(x1, x2, ..., xn), (y1, y2, ..., yn)].

  - RESULT: string reprezentujący prostokąt w postaci [(x1, x2, ..., xn), (y1, y2, ..., yn)].

  \item \textbf{\_\_len\_\_(self)}:
  Zwraca liczbę wymiarów prostokąta.

  - RESULT: liczba wymiarów prostokąta.

  \item \textbf{lowerleft(self)}:
  @property Zwraca punkt lowerleft.

  \item \textbf{upperright(self)}:
  @property Zwraca punkt upperright.

  \item \textbf{from\_points(cls, points)}:
  @classmethod Tworzy najmniejszy prostokąt zawierający wszystkie punkty (lub obiekty iterowalne) z listy points.

  - points: lista punktów (lub obiektów iterowalnych), które zostaną zawarte w prostokącie.

  - RESULT: najmniejszy prostokąt zawierający wszystkie punkty z listy points.

  Wywołuje ValueError("Cannot create a Rectangle from an empty list of points") jeśli lista points jest pusta.

  Wywołuje ValueError("Points must have the same dimensionality") jeśli wymiary punktów nie są równe.

  \item \textbf{does\_intersect(self, other)}:
  Sprawdza czy dwa prostokąty przecinają się (mają conajmniej jeden punkt wspólny), zwraca True jeśli tak, w przeciwnym wypadku False.

  - other: prostokąt, który zostanie sprawdzony pod kątem przecięcia z prostokątem.

  - RESULT: True jeśli prostokąty przecinają się, False w przeciwnym wypadku.

  Wywołuje ValueError("Can only check intersection with another Rectangle") jeśli other nie jest prostokątem.

  Wywołuje ValueError("Can only check intersection with a Rectangle of the same dimensionality") jeśli wymiary prostokątów nie są równe.

  \item \textbf{contains(self, object)}:
  Sprawdza czy punkt lub prostokąt jest całkowicie zawarty w prostokącie, zwraca True jeśli tak, w przeciwnym wypadku False. Jeśli obiekt nie jest prostokątem, funkcja uznaje go za punkt.

  - object: punkt lub prostokąt, który zostanie sprawdzony pod kątem zawierania w prostokącie.

  - RESULT: True jeśli obiekt jest zawarty w prostokącie, False w przeciwnym wypadku.

  \item \textbf{divide(self, dimension, value)}:
  Dzieli prostokąt na dwa prostokąty wzdłuż wymiaru dimension i wartości value, zwraca krotkę dwóch prostokątów.

  - dimension: wymiar, wzdłuż którego następuje podział prostokąta.

  - value: wartość, względem której następuje podział prostokąta.

  - RESULT: krotka dwóch prostokątów.

  Wywołuje ValueError("Dimension must be between 0 and {len(self)-1}") jeśli wymiar dimension jest mniejszy niż 0 lub większy niż liczba wymiarów prostokąta - 1.

  Wywołuje ValueError("Value must be between {self.lowerleft[dimension]} and {self.upperright[dimension]}") jeśli wartość value jest mniejsza niż wartość wymiaru dimension punktu lowerleft lub większa niż wartość wymiaru dimension punktu upperright.

  \item \textbf{intersection(self, other)}:
  Zwraca prostokąt będący częścią wspólną dwóch prostokątów lub None jeśli prostokąty się nie przecinają.

  - other: prostokąt, z którym zostanie wyznaczona część wspólna.

  - RESULT: prostokąt będący częścią wspólną dwóch prostokątów lub None jeśli prostokąty się nie przecinają.

  Wywołuje ValueError("Can only compute intersection with another Rectangle") jeśli other nie jest prostokątem.

  Wywołuje ValueError("Can only compute intersection with a Rectangle of the same dimensionality") jeśli wymiary prostokątów nie są równe.

  \item \textbf{vertices2D(self)}:
  @property Zwraca listę punktów będących wierzchołkami prostokąta, jeśli prostokąt jest dwuwymiarowy.

  Wywołuje ValueError("Can only compute vertices of a 2D rectangle") jeśli prostokąt nie jest dwuwymiarowy.

  \item \textbf{opposite(self, point, depth)}:
  Zwraca dwa punkty leżące na przeciwległych bokach prostokąta o dwóch wymiarach, wzdłuż wymiaru depth, takie że point również leży na tym odcinku.

  - point: punkt, względem którego zostaną wyznaczone punkty leżące na przeciwległych bokach prostokąta.

  - depth: wymiar, wzdłuż którego zostaną wyznaczone punkty leżące na przeciwległych bokach prostokąta.

  Wywołuje ValueError("Can only compute opposite points of a 2D rectangle") jeśli prostokąt nie jest dwuwymiarowy. 

  \item \textbt{center(self)}:
  Zwraca punkt będący środkiem prostokąta.

  - RESULT: punkt będący środkiem prostokąta.

  \item \textbf{to\_quaters(self)}:
  Dzieli prostokąt na cztery równe podprostokąty, zwraca listę podprostokątów klasy Rectangle.

  - RESULT: lista podprostokątów klasy Rectangle.

  Wywołuje ValueError("Can only divide a 2D rectangle") jeśli prostokąt nie jest dwuwymiarowy.
\end{itemize}

\section{QuadTree}
Plik zawiera implementację drzewa QuadTree (QuadTree) oraz jego bliźniaczą wersję (QuadTree\_visualizer), która umożliwia wizualizację drzewa w postaci gifów.
\subsection{QuadTree}
Klasa implementująca drzewo QuadTree wraz z metodami wyszukiwania oraz weryfikacją danych wejściowych.
\begin{itemize}
  \item \textbf{QuadTree(points, max\_capacity=1, points\_in\_node=False)}:
  Konstruktor drzewa przyjmuje listę punktów (obiekty klasy Point lub obiektów iterowalnych) jako argument i tworzy drzewo zawierające te punkty.

  - points: lista punktów (obiektów klasy Point lub obiektów iterowalnych), które będą przechowywane w drzewie.

  - max\_capacity: maksymalna liczba punktów w węźle, po przekroczeniu której następuje podział węzła.

  - points\_in\_node: określa czy w każdym węźle przechowywana jest lista znajdujących się w nim punktów (True), czy tylko w liściach (False).

  - RESULT: drzewo QuadTree zawierające punkty z listy points.

  Wywołuje ValueError("The list of points is empty.") jeśli lista points jest pusta.

  Wywołuje ValueError("The points have dimensions different than 2.") jeśli wymiary punktów nie są równe 2.

  Wywołuje ValueError("The max capacity must be greater than 0.") jeśli max\_capacity jest mniejsze niż 1.

  Wywołuje ValueError("Not all points are unique.") jeśli lista points zawiera duplikaty.

  \item \textbf{if\_contains(self, point)}:
  Sprawdza czy drzewo zawiera punkt (obiekt klasy Point lub obiekt iterowalny), zwraca True jeśli tak, w przeciwnym wypadku False.

  - point: punkt (obiekt klasy Point lub obiekt iterowalny), który ma zostać wyszukany w drzewie.

  - RESULT: True jeśli drzewo zawiera punkt, False w przeciwnym wypadku.

  Wywołuje ValueError("The point has different dimension than 2.") jeśli wymiary punktu nie są równe 2.

  \item \textbf{search\_in\_rectangle(self, rectangle, raw=False)}:
  Wyszukuje punkty znajdujące się w prostokącie (obiekt klasy Rectangle), zwraca listę punktów (obiektów klasy Point) lub listę list punktów (obiektów klasy Point) w zależności od wartości parametru raw.

  - rectangle: prostokąt (obiekt klasy Rectangle), w którym wyszukiwane są punkty.

  - raw: określa czy zwracana lista ma zawierać obiekty klasy Point (False) lub listy współrzędnych punktów (True).

  - RESULT: lista punktów (obiektów klasy Point) lub lista list punktów (obiektów klasy Point) w zależności od wartości parametru raw.

  Wywołuje ValueError("The rectanangle is not a Rectangle object.") jeśli rectangle nie jest obiektem klasy Rectangle.

  Wywołuje ValueError("The rectangle has different dimension than 2.") jeśli wymiary prostokąta nie są równe 2.
\end{itemize}

\subsection{QuadTree\_visualizer}
Klasa implementująca drzewo QuadTree wraz z metodami wyszukiwania oraz weryfikacją danych wejściowych. Dodatkowo umożliwia wizualizację drzewa w postaci gifów.
\begin{itemize}
  \item \textbf{QuadTree\_visualizer(points, max\_capacity=1, points\_in\_node=False, visualize\_gif=True, title="QuadTree", filename="QuadTree-construction")}:
  Konstruktor drzewa przyjmuje listę punktów (obiekty klasy Point lub obiektów iterowalnych) jako argument i tworzy drzewo zawierające te punkty. Dodatkowo tworzy obiekt klasy Visualizer i zapisuje plik o rozszerzeniu .gif w tym samym folderze.

  - points: lista punktów (obiektów klasy Point lub obiektów iterowalnych), które będą przechowywane w drzewie.

  - max\_capacity: maksymalna liczba punktów w węźle, po przekroczeniu której następuje podział węzła.

  - points\_in\_node: określa czy w każdym węźle przechowywana jest lista znajdujących się w nim punktów (True), czy tylko w liściach (False).

  - visualize\_gif: określa czy wizualizacja drzewa ma zostać zapisana w pliku .gif, czy tylko wyświetlona.

  - title: tytuł wyświetlany na wykresie.

  - filename: nazwa pliku .gif, w którym zapisywana jest wizualizacja.

  - RESULT: drzewo QuadTree zawierające punkty z listy points.

  Wywołuje ValueError("The list of points is empty.") jeśli lista points jest pusta.

  Wywołuje ValueError("The points have dimensions different than 2.") jeśli wymiary punktów nie są równe 2.

  Wywołuje ValueError("The max capacity must be greater than 0.") jeśli max\_capacity jest mniejsze niż 1.

  Wywołuje ValueError("Not all points are unique.") jeśli lista points zawiera duplikaty.

  Legenda:
  \begin{itemize}
      \item \textbf{\textcolor{blue}{Granatowe odcinki}}: odcinki reprezentujące podział węzła.
      \item \textbf{\textcolor{cyan}{Niebieskie punkty}}: punkty nieprzetworzone.
      \item \textbf{\textcolor{red}{Czerwone punkty}}: punkty aktualnie przetwarzane.
      \item \textbf{\textcolor{orange}{Pomarańczowe punkty}}: punkty przetworzone.
      \item \textbf{\textcolor{pink}{Żółty obszar}}: obszar aktualnie przetwarzany.
  \end{itemize}
  \item \textbf{if\_contains(self, point, visualize\_gif=True, title="QuadTree", filename="QuadTree-contains")}:
  Sprawdza czy drzewo zawiera punkt (obiekt klasy Point lub obiekt iterowalny), zwraca True jeśli tak, w przeciwnym wypadku False. Dodatkowo tworzy obiekt klasy Visualizer i zapisuje plik o rozszerzeniu .gif w tym samym folderze.

  - point: punkt (obiekt klasy Point lub obiekt iterowalny), który ma zostać wyszukany w drzewie.

  - visualize\_gif: określa czy wizualizacja drzewa ma zostać zapisana w pliku .gif, czy tylko wyświetlona.

  - title: tytuł wyświetlany na wykresie.

  - filename: nazwa pliku .gif, w którym zapisywana jest wizualizacja.

  - RESULT: True jeśli drzewo zawiera punkt, False w przeciwnym wypadku.

  Wywołuje ValueError("The point has different dimension than 2.") jeśli wymiary punktu nie są równe 2.

  Legenda:
  \begin{itemize}
      \item \textbf{\textcolor{blue}{Granatowe odcinki}}: odcinki reprezentujące podział węzła.
      \item \textbf{\textcolor{cyan}{Niebieskie punkty}}: punkty nieprzetworzone.
      \item \textbf{\textcolor{red}{Czerwone punkty}}: punkty aktualnie przetwarzane.
      \item \textbf{\textcolor{orange}{Pomarańczowe punkty}}: punkty przetworzone.
      \item \textbf{\textcolor{green}{Zielony punkt}}: punkt, który został znaleziony.
      \item \textbf{\textcolor{black}{Czarny punkt}}: lokalizacja punktu, który nie został znaleziony.
      \item \textbf{\textcolor{pink}{Żółty obszar}}: obszar aktualnie przetwarzany.
  \end{itemize}

  \item \textbf{search\_in\_rectangle(self, rectangle, visualize\_gif=True, raw=False, title="QuadTree", filename= "QuadTree-search")}:
  Wyszukuje punkty znajdujące się w prostokącie (obiekt klasy Rectangle), zwraca listę punktów (obiektów klasy Point) lub listę list punktów (obiektów klasy Point) w zależności od wartości parametru raw. Dodatkowo tworzy obiekt klasy Visualizer i zapisuje plik o rozszerzeniu .gif w tym samym folderze.

  - rectangle: prostokąt (obiekt klasy Rectangle), w którym wyszukiwane są punkty.

  - visualize\_gif: określa czy wizualizacja drzewa ma zostać zapisana w pliku .gif, czy tylko wyświetlona.

  - raw: określa czy zwracana lista ma zawierać obiekty klasy Point (False) lub listy współrzędnych punktów (True).

  - title: tytuł wyświetlany na wykresie.

  - filename: nazwa pliku .gif, w którym zapisywana jest wizualizacja.

  - RESULT: lista punktów (obiektów klasy Point) lub lista list punktów (obiektów klasy Point) w zależności od wartości parametru raw.

  Wywołuje ValueError("The rectanangle is not a Rectangle object.") jeśli rectangle nie jest obiektem klasy Rectangle.

  Wywołuje ValueError("The rectangle has different dimension than 2.") jeśli wymiary prostokąta nie są równe 2.

  Legenda:
  \begin{itemize}
      \item \textbf{\textcolor{blue}{Granatowe odcinki}}: odcinki reprezentujące podział węzła.
      \item \textbf{\textcolor{red}{Czerwone odcinki}}: odcinki reprezentujące obszar przeszukiwania.
      \item \textbf{\textcolor{cyan}{Niebieskie punkty}}: punkty nieprzetworzone.
      \item \textbf{\textcolor{red}{Czerwone punkty}}: punkty aktualnie przetwarzane.
      \item \textbf{\textcolor{orange}{Pomarańczowe punkty}}: punkty przetworzone.
      \item \textbf{\textcolor{green}{Zielony punkt}}: punkt, który został znaleziony.
      \item \textbf{\textcolor{pink}{Żółty obszar}}: obszar aktualnie przetwarzany.
  \end{itemize}
\end{itemize}

\section{KdTree}
Plik zawiera implementację drzewa KdTree (KdTree) oraz jego bliźniaczą wersję (KdTree\_visualizer), która umożliwia wizualizację drzewa w postaci gifów.
\subsection{KdTree}
Klasa implementująca drzewo KdTree wraz z metodami wyszukiwania oraz weryfikacją danych wejściowych.
\begin{itemize}
  \item \textbf{KdTree(points, depth=0, points\_in\_node=False)}:
  Konstruktor drzewa przyjmuje listę punktów (obiekty klasy Point lub obiektów iterowalnych) jako argument i tworzy drzewo zawierające te punkty.
  
  - points: lista punktów (obiektów klasy Point lub obiektów iterowalnych), które będą przechowywane w drzewie.

  - depth: głębokość węzła, operacja $\%len(point)$ wskazuje na wymiar, w którym następuje podział węzła.

  - points\_in\_node: określa czy w każdym węźle przechowywana jest lista znajdujących się w nim punktów (True), czy tylko w liściach (False).

  - RESULT: drzewo KdTree zawierające punkty z listy points.

  Wywołuje ValueError("The list of points is empty.") jeśli lista points jest pusta.

  Wywołuje ValueError("The points have different dimensions.") jeśli wymiary punktów nie są równe.
  
  \item \textbf{if\_contains(self, point)}:
  Sprawdza czy drzewo zawiera punkt (obiekt klasy Point lub obiekt iterowalny), zwraca True jeśli tak, w przeciwnym wypadku False.

  - point: punkt (obiekt klasy Point lub obiekt iterowalny), który ma zostać wyszukany w drzewie.

  - RESULT: True jeśli drzewo zawiera punkt, False w przeciwnym wypadku.

  Wywołuje ValueError("The point has different dimension than the points in the tree.") jeśli wymiary punktu nie są równe wymiarom punktów w drzewie.

  \item \textbf{search\_in\_rectangle(self, rectangle, raw=False)}:
  Wyszukuje punkty znajdujące się w prostokącie (obiekt klasy Rectangle), zwraca listę punktów (obiektów klasy Point) lub listę list punktów (obiektów klasy Point) w zależności od wartości parametru raw.

  - rectangle: prostokąt (obiekt klasy Rectangle), w którym wyszukiwane są punkty.

  - raw: określa czy zwracana lista ma zawierać obiekty klasy Point (False) lub listy współrzędnych punktów (True).

  - RESULT: lista punktów (obiektów klasy Point) lub lista list punktów (obiektów klasy Point) w zależności od wartości parametru raw.

  Wywołuje ValueError("The rectanangle is not a Rectangle object.") jeśli rectangle nie jest obiektem klasy Rectangle.

  Wywołuje ValueError("The rectangle has different dimension than the points in the tree.") jeśli wymiary prostokąta nie są równe wymiarom punktów w drzewie.
\end{itemize}

\subsection{KdTree\_visualizer}
Klasa implementująca drzewo KdTree wraz z metodami wyszukiwania oraz weryfikacją danych wejściowych. Dodatkowo umożliwia wizualizację drzewa w postaci gifów.
\begin{itemize}
  \item \textbf{KdTree\_visualizer(points, depth=0, points\_in\_node=False, visualize\_gif=True, title="KdTree", filename="KdTree-construction")}:
  Konstruktor drzewa przyjmuje listę punktów (obiekty klasy Point lub obiektów iterowalnych) jako argument i tworzy drzewo zawierające te punkty. Dodatkowo tworzy obiekt klasy Visualizer i zapisuje plik o rozszerzeniu .gif w tym samym folderze.

  - points: lista punktów (obiektów klasy Point lub obiektów iterowalnych), które będą przechowywane w drzewie.

  - depth: głębokość węzła, operacja $\%len(point)$ wskazuje na wymiar, w którym następuje podział węzła.

  - points\_in\_node: określa czy w każdym węźle przechowywana jest lista znajdujących się w nim punktów (True), czy tylko w liściach (False).

  - visualize\_gif: określa czy wizualizacja drzewa ma zostać zapisana w pliku .gif (True), czy tylko wyświetlona (False).

  - title: tytuł wyświetlany na wykresie.

  - filename: nazwa pliku .gif, w którym zapisywana jest wizualizacja.

  - RESULT: drzewo KdTree zawierające punkty z listy points.

  Wywołuje ValueError("The list of points is empty.") jeśli lista points jest pusta.

  Wywołuje ValueError("The points have different dimensions.") jeśli wymiary punktów nie są równe.

  Wywołuje ValueError("Not all points are unique.") jeśli lista points zawiera duplikaty.

  Legenda:
  \begin{itemize}
      \item \textbf{\textcolor{blue}{Granatowe odcinki}}: odcinki reprezentujące podział węzła.
      \item \textbf{\textcolor{cyan}{Niebieskie punkty}}: punkty nieprzetworzone.
      \item \textbf{\textcolor{red}{Czerwone punkty}}: punkty aktualnie przetwarzane.
      \item \textbf{\textcolor{orange}{Pomarańczowe punkty}}: punkty przetworzone.
      \item \textbf{\textcolor{pink}{Żółty obszar}}: obszar aktualnie przetwarzany.
  \end{itemize}

  \item \textbf{if\_contains(self, point, visualize\_gif=True, title="KdTree", filename="KdTree-contains")}:
  Sprawdza czy drzewo zawiera punkt (obiekt klasy Point lub obiekt iterowalny), zwraca True jeśli tak, w przeciwnym wypadku False. Dodatkowo tworzy obiekt klasy Visualizer i zapisuje plik o rozszerzeniu .gif w tym samym folderze.

  - point: punkt (obiekt klasy Point lub obiekt iterowalny), który ma zostać wyszukany w drzewie.

  - visualize\_gif: określa czy wizualizacja drzewa ma zostać zapisana w pliku .gif (True), czy tylko wyświetlona (False).

  - title: tytuł wyświetlany na wykresie.

  - filename: nazwa pliku .gif, w którym zapisywana jest wizualizacja.

  - RESULT: True jeśli drzewo zawiera punkt, False w przeciwnym wypadku.

  Wywołuje ValueError("The point has different dimension than the points in the tree.") jeśli wymiary punktu nie są równe wymiarom punktów w drzewie.

  Legenda:
  \begin{itemize}
      \item \textbf{\textcolor{blue}{Granatowe odcinki}}: odcinki reprezentujące podział węzła.
      \item \textbf{\textcolor{cyan}{Niebieskie punkty}}: punkty nieprzetworzone.
      \item \textbf{\textcolor{red}{Czerwone punkty}}: punkty aktualnie przetwarzane.
      \item \textbf{\textcolor{orange}{Pomarańczowe punkty}}: punkty przetworzone.
      \item \textbf{\textcolor{green}{Zielony punkt}}: punkt, który został znaleziony.
      \item \textbf{\textcolor{black}{Czarny punkt}}: lokalizacja punktu, który nie został znaleziony.
      \item \textbf{\textcolor{pink}{Żółty obszar}}: obszar aktualnie przetwarzany.
  \end{itemize}

  \item \textbf{search\_in\_rectangle(self, rectangle, raw=False, visualize\_gif=True, title="KdTree", filename= "KdTree-search")}:
  Wyszukuje punkty znajdujące się w prostokącie (obiekt klasy Rectangle), zwraca listę punktów (obiektów klasy Point) lub listę list punktów (obiektów klasy Point) w zależności od wartości parametru raw. Dodatkowo tworzy obiekt klasy Visualizer i zapisuje plik o rozszerzeniu .gif w tym samym folderze.

  - rectangle: prostokąt (obiekt klasy Rectangle), w którym wyszukiwane są punkty.

  - raw: określa czy zwracana lista ma zawierać obiekty klasy Point (False) lub listy współrzędnych punktów (True).

  - visualize\_gif: określa czy wizualizacja drzewa ma zostać zapisana w pliku .gif (True), czy tylko wyświetlona (False).

  - title: tytuł wyświetlany na wykresie.

  - filename: nazwa pliku .gif, w którym zapisywana jest wizualizacja.

  - RESULT: lista punktów (obiektów klasy Point) lub lista list punktów (obiektów klasy Point) w zależności od wartości parametru raw.

  Wywołuje ValueError("The rectanangle is not a Rectangle object.") jeśli rectangle nie jest obiektem klasy Rectangle.

  Wywołuje ValueError("The rectangle has different dimension than the points in the tree.") jeśli wymiary prostokąta nie są równe wymiarom punktów w drzewie.

  Legenda:
  \begin{itemize}
      \item \textbf{\textcolor{blue}{Granatowe odcinki}}: odcinki reprezentujące podział węzła.
      \item \textbf{\textcolor{red}{Czerwone odcinki}}: odcinki reprezentujące obszar przeszukiwania.
      \item \textbf{\textcolor{cyan}{Niebieskie punkty}}: punkty nieprzetworzone.
      \item \textbf{\textcolor{red}{Czerwone punkty}}: punkty aktualnie przetwarzane.
      \item \textbf{\textcolor{orange}{Pomarańczowe punkty}}: punkty przetworzone.
      \item \textbf{\textcolor{green}{Zielony punkt}}: punkt, który został znaleziony.
      \item \textbf{\textcolor{pink}{Żółty obszar}}: obszar aktualnie przetwarzany.
  \end{itemize}
\end{itemize}

\section{Comparator}
Moduł zawiera implementację porównania drzew QuadTree i KdTree oraz klasę generującą przypadki testowe.
\subsection{CaseGenerator}
Klasa generująca przypadki testowe dla struktur QuadTree i KdTree.
\begin{itemize}
  \item \textbf{CaseGenerator()}:
  Konstruktor klasy CaseGenerator.
  \item \textbf{uniform\_distribution(self, quantity, rectangle, raw=True)}:
  Generuje punkty z rozkładem jednorodnym wewnątrz prostokąta.

  - quantity: liczba punktów do wygenerowania.

  - rectangle: prostokąt (obiekt klasy Rectangle), w którym mają zostać wygenerowane punkty.

  - raw: określa czy zwracana lista ma zawierać obiekty klasy Point (False) lub listy współrzędnych punktów (True).

  - RESULT: lista punktów (obiektów klasy Point) lub lista list punktów (obiektów klasy Point) w zależności od wartości parametru raw.

  Wywołuje ValueError("quantity must be positive") jeśli quantity jest mniejsze od 0.

  Wywołuje ValueError("The rectanangle is not a Rectangle object.") jeśli rectangle nie jest obiektem klasy Rectangle.

  \item \textbf{normal\_distribution(self, quantity, rectangle, raw=True, mu=None, sigma=None)}:

  Generuje punkty z rozkładem normalnym wewnątrz prostokąta.

  - quantity: liczba punktów do wygenerowania.

  - rectangle: prostokąt (obiekt klasy Rectangle), w którym mają zostać wygenerowane punkty.

  - raw: określa czy zwracana lista ma zawierać obiekty klasy Point (False) lub listy współrzędnych punktów (True).

  - mu: wartość oczekiwana rozkładu normalnego, w przypadku None wartość oczekiwana jest wyznaczana jako środek prostokąta. Musi być listą o takiej samej długości jak wymiary prostokąta.

  - sigma: odchylenie standardowe rozkładu normalnego, w przypadku None odchylenie standardowe jest wyznaczane jako 1/6 długości boku prostokąta. Przy dużych wartościach sigma punkty mogą znajdować się poza prostokątem. Musi być listą o takiej samej długości jak wymiary prostokąta.

  - RESULT: lista punktów (obiektów klasy Point) lub lista list punktów (obiektów klasy Point) w zależności od wartości parametru raw.

  Wywołuje ValueError("quantity must be positive") jeśli quantity jest mniejsze od 0.

  Wywołuje ValueError("The rectanangle is not a Rectangle object.") jeśli rectangle nie jest obiektem klasy Rectangle.

  Wywołuje ValueError("mu must be list") jeśli mu nie jest listą.

  Wywołuje ValueError("mu must have the same dimensionality as rectangle") jeśli wymiary mu nie są równe wymiarom prostokąta.

  Wywołuje ValueError("sigma must be list") jeśli sigma nie jest listą.

  Wywołuje ValueError("sigma must have the same dimensionality as rectangle") jeśli wymiary sigma nie są równe wymiarom prostokąta.

  \item \textbf{grid\_distribution(self, quantity, rectangle, raw=True)}:
  Generuje równo rozłożone punkty w siatce wewnątrz prostokąta.

  - quantity: krotka (columns, rows) określająca liczbę kolumn i wierszy punktów do wygenerowania.

  - rectangle: prostokąt (obiekt klasy Rectangle), w którym mają zostać wygenerowane punkty.

  - raw: określa czy zwracana lista ma zawierać obiekty klasy Point (False) lub listy współrzędnych punktów (True).

  - RESULT: lista punktów (obiektów klasy Point) lub lista list punktów (obiektów klasy Point) w zależności od wartości parametru raw.

  Wywołuje ValueError("Quantity must be a tuple of two positive integers") jeśli quantity nie jest krotką dwóch liczb całkowitych większych od 0.

  Wywołuje ValueError("columns must be positive") jeśli columns jest mniejsze od 0.

  Wywołuje ValueError("rows must be positive") jeśli rows jest mniejsze od 0.

  Wywołuje ValueError("The rectanangle is not a Rectangle object.") jeśli rectangle nie jest obiektem klasy Rectangle.

  \item \textbf{cluster\_distribution(self, quantity, clusters, raw=True)}:
  Generuje punkty w klastrach wewnątrz prostokąta.

  - quantity: liczba punktów do wygenerowania w każdym klastrze.

  - clusters: lista prostokątów (obiektów klasy Rectangle), w których mają zostać wygenerowane punkty.

  - raw: określa czy zwracana lista ma zawierać obiekty klasy Point (False) lub listy współrzędnych punktów (True).

  - RESULT: lista punktów (obiektów klasy Point) lub lista list punktów (obiektów klasy Point) w zależności od wartości parametru raw.

  Wywołuje ValueError("quantity must be positive") jeśli quantity jest mniejsze od 0.

  Wywołuje ValueError("The rectanangle is not a Rectangle object.") jeśli element listy clusters nie jest obiektem klasy Rectangle.

  \item \textbf{outliers\_distribution(self, quantities, rectangle, raw=True)}:
  Generuje punkty wewnątrz prostokąta wraz z punktami odstającymi. Punkty są generowane w środku dwukrotnie mniejszego prostokąta przy zachowaniu tego samego punktu centralnego, a punkty odstające na przestrzeni całego prostokąta.

  - quantities: krotka (quantity, outliers) określająca liczbę punktów i punktów odstających do wygenerowania.

  - outliers: liczba punktów odstających do wygenerowania.

  - rectangle: prostokąt (obiekt klasy Rectangle), w którym mają zostać wygenerowane punkty.

  - raw: określa czy zwracana lista ma zawierać obiekty klasy Point (False) lub listy współrzędnych punktów (True).

  - RESULT: lista punktów (obiektów klasy Point) lub lista list punktów (obiektów klasy Point) w zależności od wartości parametru raw.

  Wywołuje ValueError("quantity must be positive") jeśli quantity jest mniejsze od 0.

  Wywołuje ValueError("outliers must be positive") jeśli outliers jest mniejsze od 0.

  Wywołuje ValueError("The rectanangle is not a Rectangle object.") jeśli rectangle nie jest obiektem klasy Rectangle.

  \item \textbf{cross\_distribution(self, quantity, rectangle, raw=True)}:
  Generuje punkty wewnątrz prostokąta na jego osiach symetrii względem jego boków.

  - quantity: krotka (vertical, horizontal) określająca liczbę punktów do wygenerowania w pionie i poziomie.

  - rectangle: prostokąt (obiekt klasy Rectangle), w którym mają zostać wygenerowane punkty.

  - raw: określa czy zwracana lista ma zawierać obiekty klasy Point (False) lub listy współrzędnych punktów (True).

  - RESULT: lista punktów (obiektów klasy Point) lub lista list punktów (obiektów klasy Point) w zależności od wartości parametru raw.

  Wywołuje ValueError("vertical must be positive") jeśli vertical jest mniejsze od 0.

  Wywołuje ValueError("horizontal must be positive") jeśli horizontal jest mniejsze od 0.

  Wywołuje ValueError("The rectanangle is not a Rectangle object.") jeśli rectangle nie jest obiektem klasy Rectangle.

  \item \textbf{rectangle\_distribution(self, quantity, rectangle, raw=True)}:
  Generuje punkty na bokach prostokąta.

  - quantity: liczba punktów do wygenerowania.

  - rectangle: prostokąt (obiekt klasy Rectangle), w którego bokach mają zostać wygenerowane punkty.

  - raw: określa czy zwracana lista ma zawierać obiekty klasy Point (False) lub listy współrzędnych punktów (True).

  - RESULT: lista punktów (obiektów klasy Point) lub lista list punktów (obiektów klasy Point) w zależności od wartości parametru raw.

  Wywołuje ValueError("quantity must be positive") jeśli quantity jest mniejsze od 0.

  Wywołuje ValueError("The rectanangle is not a Rectangle object.") jeśli rectangle nie jest obiektem klasy Rectangle.
\end{itemize}

\subsection{Comparision.ipynb}
Jupyter Notebook zawierający porównanie wydajności struktur QuadTree i KdTree wraz z generacją wykresów. Składa się z czterech części:
\begin{itemize}
  \item \textbf{Sprawdzenie poprawności działania porównywanych struktur}:
  Sprawdzenie poprawności działania struktur QuadTree i KdTree za pomocą testów jednostkowych z modułu Tests.
  \item \textbf{Pomiary wydajności struktur QuadTree i KdTree dla różnych danych wejściowych oraz ich rozmiaru}:
  Pomiar czasu działania struktur QuadTree i KdTree dla różnych danych wejściowych wygenerowanych za pomocą CaseGenerator.
  \item \textbf{Generowanie wykresów}:
  Generowanie wykresów na podstawie danych z poprzedniej części.
  \item \textbf{Pomiary dla indywidualnych przypadków pod zastosowania drzewa}:
  Wykorzystanie drzew pod względem ich unikalnych możliwości.
  \item \textbf{Wizualizacja powyższych zbiorów, oraz siatki}:
  Wizualizacja zbiorów danych wejściowych oraz siatek utworzonych przez drzewa.
\end{itemize}

\section{Tests}
Moduł zawiera testy jednostkowe oraz integracyjne dla struktur QuadTree, KdTree oraz jednostkowe wszystkich komponentów.
\subsection{TestManager}
Klasa zawierająca testy integracyjne dla struktur QuadTree i KdTree.
\begin{itemize}
  \item \textbf{TestManager(tree)}:
  Konstruktor klasy TestManager.

  - tree: drzewo (obiekt klasy QuadTree lub KdTree), które ma zostać przetestowane.

  \item \textbf{all\_tests(self)}:
  Wykonuje wszystkie integracyjne zawarte w klasie TestManager. Przebieg jest wyświetlany w konsoli.

  - RESULT: True jeśli wszystkie testy zakończyły się sukcesem, False w przeciwnym wypadku.

  \item \textbf{all\_unittests(self)}:
  Wykonuje wszystkie jednostkowe zawarte w klasie TestManager. Przebieg jest wyświetlany w konsoli.
  wykorzystuje bibliotekę unittest.

  \item \textbf{contain\_point\_int(self)}:
  Testuje metodę if\_contains dla punktów całkowitoliczbowych. Przebieg jest wyświetlany w konsoli.

  - RESULT: krotka (good, all), gdzie good to liczba testów zakończonych sukcesem, a all to liczba wszystkich testów.

  \item \textbf{contain\_point\_float(self)}:
  Testuje metodę if\_contains dla punktów zmiennoprzecinkowych. Przebieg jest wyświetlany w konsoli.

  - RESULT: krotka (good, all), gdzie good to liczba testów zakończonych sukcesem, a all to liczba wszystkich testów.

  \item \textbf{search\_in\_rectangle\_int(self)}:
  Testuje metodę search\_in\_rectangle dla punktów całkowitoliczbowych. Przebieg jest wyświetlany w konsoli.

  - RESULT: krotka (good, all), gdzie good to liczba testów zakończonych sukcesem, a all to liczba wszystkich testów.

  \item \textbf{search\_in\_rectangle\_float(self)}:
  Testuje metodę search\_in\_rectangle dla punktów zmiennoprzecinkowych. Przebieg jest wyświetlany w konsoli.

  - RESULT: krotka (good, all), gdzie good to liczba testów zakończonych sukcesem, a all to liczba wszystkich testów.
\end{itemize}

\section{Visualizer}
Moduł zawiera narzędzie do wizualizacji oraz przykładowe wizualizacje.
Narzędzie pochodzi z repozytorium dostarczonego przez KN AGH BIT, link do repozytorium znajduje się w bibliografii.
\subsection{main.py}
Plik zawiera implementację klasy Visualizer, która umożliwia wizualizacje. Został oparty na możliwościach biblioteki matplotlib.
\begin{itemize}
  \item \textbf{Visualizer()}:
  Konstruktor klasy Visualizer.

  \item \textbf{add\_title(self, title)}:
  Dodaje tytuł wykresu.

  - title: tytuł wykresu.

  \item \textbf{add\_grid(self)}:
  Dodaje siatkę do wykresu.

  \item \textbf{add\_point(self, data, **kwargs)}:
  Dodaje punkt do wykresu.

  - data: punkt (obiekt iterowalny) który ma zostać dodany do wykresu.

  - kwargs: dodatkowe argumenty, które zostaną przekazane do funkcji matplotlib.pyplot.plot.

  - RESULT: obiekt klasy figure, który został dodany do wykresu.

  \item \textbf{add\_line\_segment(self, data, **kwargs)}:
  Dodaje odcinek do wykresu.

  - data: odcinek który ma zostać dodany do wykresu.

  - kwargs: dodatkowe argumenty, które zostaną przekazane do funkcji matplotlib.pyplot.plot.

  - RESULT: obiekt klasy figure, który został dodany do wykresu.

  \item \textbf{add\_circle(self, data, **kwargs)}:
  Dodaje okrąg do wykresu.

  - data: okrąg który ma zostać dodany do wykresu.

  - kwargs: dodatkowe argumenty, które zostaną przekazane do funkcji matplotlib.pyplot.plot.

  - RESULT: obiekt klasy figure, który został dodany do wykresu.

  \item \textbf{add\_polygon(self, data, **kwargs)}:
  Dodaje wielokąt do wykresu.

  - data: wielokąt który ma zostać dodany do wykresu.

  - kwargs: dodatkowe argumenty, które zostaną przekazane do funkcji matplotlib.pyplot.plot.

  - RESULT: obiekt klasy figure, który został dodany do wykresu.

  \item \textbf{add\_line(self, data, **kwargs)}:
  Dodaje prostą do wykresu.

  - data: prosta która ma zostać dodana do wykresu.

  - kwargs: dodatkowe argumenty, które zostaną przekazane do funkcji matplotlib.pyplot.plot.

  - RESULT: obiekt klasy figure, który został dodany do wykresu.

  \item \textbf{add\_half\_line(self, data, **kwargs)}:
  Dodaje półprostą do wykresu.

  - data: półprosta która ma zostać dodana do wykresu.

  - kwargs: dodatkowe argumenty, które zostaną przekazane do funkcji matplotlib.pyplot.plot.

  - RESULT: obiekt klasy figure, który został dodany do wykresu.

  \item \textbf{remove\_figure(self, figure)}:
  Usuwa figurę z wykresu.
  
  - figure: figura (obiekt klasy figure), która ma zostać usunięta z wykresu.

  \item \textbf{clear(self)}:
  Usuwa wszystkie figury z wykresu.

  \item \textbf{show(self)}:
  Wyświetla wykres.

  \item \textbf{save(self, filename='plot')}:
  Zapisuje wykres do pliku.

  - filename: nazwa pliku, w którym ma zostać zapisany wykres.

  \item \textbf{show\_gif(self, interval=256)}:
  Wyświetla animację wykresu.

  - interval: czas trwania jednej klatki animacji w milisekundach.

  - RESULT: obiekt klasy Image, który został wyświetlony.

  \item \textbf{save\_gif(self, filename='animation', interval=256)}:
  Zapisuje animację wykresu do pliku.

  - filename: nazwa pliku, w którym ma zostać zapisana animacja.

  - interval: czas trwania jednej klatki animacji w milisekundach.

  - RESULT: obiekt klasy Image, który został zapisany.
\end{itemize}

\subsection{demo.ipynb}
Plik Jupyter Notebook, który zawiera przykładowe wykorzystanie klasy Visualizer.

\newpage
\part{Instrukcja korzystania z programu}
\section{Utilities}
\subsection{Point}
Aby utworzyć punkt należy utworzyć obiekt klasy Point, który przyjmuje listę współrzędnych jako argument.
\begin{lstlisting}[
  style=vscode-darkplus-python,
  caption={Konstruktor klasy Point.},
  label=lst:python_code,
  captionpos=b
]
from utilities.point import Point

point1 = Point([1, -2])
point2 = Point([3.4, -4, 5])
# ValueError: The point must have at least one dimension.
point3 = Point([]) # ValueError
\end{lstlisting}
Na obiekcie klasy Point można wykonywać różne operacje. Gdy do wykonania operacji wymagany jest inny punkt, to musi mieć on taki sam wymiar jak punkt na którym wykonywana jest operacja.
\begin{lstlisting}[
  style=vscode-darkplus-python,
  caption={Przykładowe operacje na obiekcie klasy Point.},
  label=lst:python_code,
  captionpos=b
]
point1 = Point([1, -2])
point2 = Point([3.4, 5])
point3 = Point([3.4, -4, 5])

len(point1)             # 2
point3[2]               # 5
point2.y                # 5
point1.precedes(point2) # True
# ValueErorr: The points have different dimensions.
point1.maximum(point3)  # ValueError
\end{lstlisting}

\subsection{Rectangle}
Aby utworzyć prostokąt należy utworzyć obiekt klasy Rectangle, który przyjmuje dwa punkty (obiekty klasy Point lub obiekty iterowalne) jako argumenty.
\begin{lstlisting}[
  style=vscode-darkplus-python,
  caption={Konstruktor klasy Rectangle.},
  label=lst:python_code,
  captionpos=b
]
from utilities.rectangle import Rectangle

rectangle1 = Rectangle([1, -2], [7.4, 5])
rectangle2 = Rectangle(Point([1, -2]), Point([3.2, 5]))
rectangle3 = Rectangle([1, -2], Point([3.4, 6]))
# ValueError: The points have different dimensions.
rectangle4 = Rectangle([1, -2], [3.4, 6, 7]) # ValueError
# ValueError: LowerLeft point must precede the UpperRight point.
rectangle5 = Rectangle([3.4, 6], [1, -2])    # ValueError
\end{lstlisting}

Przykładowe operacje z wykorzystaniem obiektu klasy Rectangle.

\begin{lstlisting}[
  style=vscode-darkplus-python,
  caption={Operacje na obiekcie klasy Rectangle.},
  label=lst:python_code,
  captionpos=b
]
rectangle1 = Rectangle([1, -2], [7.4, 5])
rectangle2 = Rectangle(Point([1, -2.3]), Point([3.2, 5]))

rectangle1.lowerleft # Point([1, -2])
rectangle1.upperright # Point([7.4, 5])
Rectangle.from_points([2, 0.3], [9, 5]) # Rectangle([2, 0.3], [9, 5])
rectangle1.divide(0, 3) # [Rectangle([1, -2], [3, 5]), Rectangle([3, -2], [7.4, 5])]
rectanangle2.vertices # [Point([1, -2.3]), Point([3.2, -2.3]), 
                      #  Point([3.2, 5]), Point([1, 5])]
\end{lstlisting}

\section{QuadTree}
\subsection{Tworzenie drzewa}
Aby utworzyć drzewo należy utworzyć obiekt klasy QuadTree, który przyjmuje listę punktów (obiektów klasy Point lub obiektów iterowalnych) jako argument.
\begin{lstlisting}[
  style=vscode-darkplus-python,
  caption={Konstruktor klasy QuadTree.},
  label=lst:python_code,
  captionpos=b
]
from quadtree import QuadTree

points1 = [[1, 2], [3, 4], [5, 6]]
Qtree1 = QuadTree(points1)
points2 = [Point([1, 2]), Point([3, 4])]
Qtree2 = QuadTree(points2, points_in_node=True)
points3 = [[-1, 2.23], Point([3.3, -4]), [7.3, 43.212]]
Qtree3 = QuadTree(points3, max_capacity=3)
# ValueError: The list of points is empty.
Qtree4 = QuadTree([]) # ValueError
# ValueError: The points have different dimensions.
Qtree5 = QuadTree([[1, 2], [3, 4.3, -5]]) # ValueError
\end{lstlisting}

\subsection{Wyszukiwanie punktu}
Aby sprawdzić czy drzewo zawiera punkt należy wywołać metodę if\_contains, która przyjmuje punkt (obiekt klasy Point lub obiekt iterowalny) jako argument.

\begin{lstlisting}[
  style=vscode-darkplus-python,
  caption={Sprawdzenie czy drzewo zawiera punkt.},
  label=lst:python_code,
  captionpos=b
]
from quadtree import QuadTree

qtree = QuadTree([[1, -2.2], [3.6, 4], Point([5, 6])])
qtree.if_contains([1, -2.2])         # True
qtree.if_contains([1, 2])            # False
qtree.if_contains(Point([3.6, 4]))   # True
qtree.if_contains(Point([3.6, 4.1])) # False
# ValueError: The point has different dimension than 2.
qtree.if_contains([1, 2, 3])         # ValueError
\end{lstlisting}

\subsection{Wyszukiwanie punktów w prostokącie}
Aby wyszukać punkty znajdujące się w prostokącie należy wywołać metodę search\_in\_rectangle, która przyjmuje prostokąt (obiekt klasy Rectangle) jako argument.
\begin{lstlisting}[
  style=vscode-darkplus-python,
  caption={Wyszukiwanie punktów w prostokącie.},
  label=lst:python_code,
  captionpos=b
]
from quadtree import QuadTree

qtree = QuadTree([[1, -2.2], [3.6, 4], Point([5, 6])])
qtree.search_in_rectangle(Rectangle([0, 0], [2, 2]), raw=False) # [Point([1, -2.2])]
qtree.search_in_rectangle(Rectangle([0, 0], [3, 4]), raw=True)  # [[1, -2.2]]
qtree.search_in_rectangle(Rectangle([6, 8], [9, 9]), raw=False) # []
# ValueError: The rectanangle is not a Rectangle object.
qtree.search_in_rectangle([0, 0, 2, 2])                         # ValueError
# ValueError: The rectangle has different dimension than 2.
qtree.search_in_rectangle(Rectangle([0, 0, 4], [2, 2, 3]))      # ValueError
\end{lstlisting}

\section{KdTree}
\subsection{Tworzenie drzewa}
Aby utworzyć drzewo należy utworzyć obiekt klasy KdTree, który przyjmuje listę punktów (obiektów klasy Point lub obiektów iterowalnych) jako argument.
\begin{lstlisting}[
  style=vscode-darkplus-python,
  caption={Konstruktor klasy KdTree.},
  label=lst:python_code,
  captionpos=b
]
from kdtree import KdTree

points1 = [[1, 2], [3, 4], [5, 6]]
Ktree1 = KdTree(points1)
points2 = [Point([1, 2]), Point([3, 4])]
Ktree2 = KdTree(points2)
points3 = [[-1, 2.23, 5], Point([3.3, -4, 2]), [7.3, 43.212, 1]]
Ktree3 = KdTree(points3)
points4 = [[1, 2], [3, 4], [5, 6], [7, 8], [9, 10]]
Ktree4 = KdTree(points4, points_in_node=True)
# ValueError: The list of points is empty.
Ktree4 = KdTree([]) # ValueError
# ValueError: The points have different dimensions.
Ktree5 = KdTree([[1, 2], [3, 4.3, -5]]) # ValueError
\end{lstlisting}

\subsection{Wyszukiwanie punktu}
Aby sprawdzić czy drzewo zawiera punkt należy wywołać metodę if\_contains, która przyjmuje punkt (obiekt klasy Point lub obiekt iterowalny) jako argument.
\begin{lstlisting}[
  style=vscode-darkplus-python,
  caption={Sprawdzenie czy drzewo zawiera punkt.},
  label=lst:python_code,
  captionpos=b
]
ktree = KdTree([[1, -2.2], [3.6, 4], Point([5, 6])])
ktree.if_contains([1, -2.2])                # True
ktree.if_contains(Point([1, 2]))            # False
# ValueError: The point has different dimension than the points in the tree.
ktree.if_contains([1, 2, 3])                # ValueError
\end{lstlisting}

\subsection{Wyszukiwanie punktów w prostokącie}
Aby wyszukać punkty znajdujące się w prostokącie należy wywołać metodę search\_in\_rectangle, która przyjmuje prostokąt (obiekt klasy Rectangle) jako argument.
\begin{lstlisting}[
  style=vscode-darkplus-python,
  caption={Wyszukiwanie punktów w prostokącie.},
  label=lst:python_code,
  captionpos=b
]
ktree = KdTree([[1, -2.2], Point([3.6, 4]), [2, -6]])
kdtree.search_in_rectangle(Rectangle([0, -3], [2, 2]), raw=False) # [Point([1, -2.2])]
ktree.search_in_rectangle(Rectangle([0, -10], [3, 2]), raw=True)  # [[1,-2.2],[2,-6]]
ktree.search_in_rectangle(Rectangle([0, 0], [2, 2]))  # []
# ValueError: The rectanangle is not a Rectangle object.
ktree.search_in_rectangle([0, 0, 2, 2])                           # ValueError
# ValueError: The rectangle has different dimension than the points in the tree.
ktree.search_in_rectangle(Rectangle([0, 0, 4], [2, 2, 3]))        # ValueError
\end{lstlisting}

\section{QuadTree\_visualizer}
Klasa umożliwiająca wizualizację drzewa QuadTree.
\subsection{Wizualizacja drzewa}
Aby wizualizować drzewo należy utworzyć obiekt klasy QuadTree\_Visualizer, który przyjmuje listę punktów (obiektów klasy Point lub obiektów iterowalnych) jako argument oraz ewentualne modyfikatory. Zachowuje się tak jak wyżej opisana klasa QuadTree.
\begin{lstlisting}[
  style=vscode-darkplus-python,
  caption={Konstruktor klasy QuadTree\_Visualizer.},
  label=lst:python_code,
  captionpos=b
]
from quadtree import QuadTree_Visualizer

points1 = [[1, 2], [3, 4], [5, 6]]
# w folderze zostanie utworzony plik quadtree.gif
Qtree1 = QuadTree_Visualizer(points1, title='QuadTree', filename='quadtree')
# w folderze zostanie utworzony plik QuadTree-construction.gif
Qtree2 = QuadTree_Visualizer(points1, points_in_node=True)
\end{lstlisting}

\subsection{Wyszukiwanie punktu}
Zachowuje się tak jak wyżej opisana klasa QuadTree, z tą różnicą, że zapisuje w gifie animację wyszukiwania punktu.
\begin{lstlisting}[
  style=vscode-darkplus-python,
  caption={Wyszukiwanie punktu w QuadTree\_Visualizer.},
  label=lst:python_code,
  captionpos=b
]
points1 = [[1, 2.2], Point([3.1, 4]), [-0.5, 6]]
Qtree1 = QuadTree_Visualizer(points1, title='QuadTree', filename='quadtree-contain')
# w folderze zostanie utworzony plik Quadtree-contains.gif
Qtree1.if_contains([1, 2.2])
\end{lstlisting}

\subsection{Wyszukiwanie punktów w prostokącie}
Zachowuje się tak jak wyżej opisana klasa QuadTree, z tą różnicą, że zapisuje w gifie animację wyszukiwania punktów w prostokącie.
\begin{lstlisting}[
  style=vscode-darkplus-python,
  caption={Wyszukiwanie punktów w prostokącie w QuadTree\_Visualizer.},
  label=lst:python_code,
  captionpos=b
]
points1 = [[1, 2.2], Point([3.1, 4]), [-0.5, 6]]
Qtree1 = QuadTree_Visualizer(points1, points_in_node=True, visualize_gif=False)
# w folderze zostanie utworzony plik Quadtree-search.gif
Qtree1.search_in_rectangle(Rectangle([0, 0], [2, 2]), title='Quad1')
\end{lstlisting}

\section{KdTree\_visualizer}
Klasa umożliwiająca wizualizację operacji drzewa KdTree.
\subsection{Wizualizacja drzewa}
Zachowuje się tak jak wyżej opisana klasa KdTree. Przy tworzeniu obiektu zapisuje w folderze plik kdtree.gif z animacją tworzenia drzewa.
\begin{lstlisting}[
  style=vscode-darkplus-python,
  caption={Konstruktor klasy KdTree\_Visualizer.},
  label=lst:python_code,
  captionpos=b
]
from kdtree import KdTree_Visualizer

points1 = [[1, 2], [3, 4], [5, 6]]
# w folderze zostanie utworzony plik kdtree.gif
Ktree1 = KdTree_Visualizer(points1, title='KdTree', filename='kdtree')
# w folderze zostanie utworzony plik kdtree-construction.gif
Ktree2 = KdTree_Visualizer(points1)
\end{lstlisting}

\subsection{Wyszukiwanie punktu}
Zachowuje się tak jak wyżej opisana klasa KdTree, z tą różnicą, że zapisuje w gifie animację wyszukiwania punktu.
\begin{lstlisting}[
  style=vscode-darkplus-python,
  caption={Wyszukiwanie punktu w KdTree\_Visualizer.},
  label=lst:python_code,
  captionpos=b
]
points1 = [[1, 2.2], Point([3.1, 4]), [-0.5, 6]]
Ktree1 = KdTree_Visualizer(points1)
# w folderze zostanie utworzony plik kdtree-contain.gif
Ktree1.if_contains([1, 2.2], title='KdTree', filename='kdtree-contain')
\end{lstlisting}

\subsection{Wyszukiwanie punktów w prostokącie}
Zachowuje się tak jak wyżej opisana klasa KdTree, z tą różnicą, że zapisuje w gifie animację wyszukiwania punktów w prostokącie.
\begin{lstlisting}[
  style=vscode-darkplus-python,
  caption={Wyszukiwanie punktów w prostokącie w KdTree\_Visualizer.},
  label=lst:python_code,
  captionpos=b
]
points1 = [[1, 2.2], Point([3.1, 4]), [-0.5, 6]]
Ktree1 = KdTree_Visualizer(points1)
# w folderze zostanie utworzony plik kdtree-search.gif
Ktree1.search_in_rectangle(Rectangle([0, 0], [2, 2]))
\end{lstlisting}

\section{Testy}
Aby przetestować strukturę należy utworzyć obiekt klasy TestManager, który przyjmuje drzewo (obiekt klasy QuadTree lub KdTree) jako argument, a następnie uruchomić interesujące nas funkcje. Rezultat testów jest wyświetlany w konsoli.
\begin{lstlisting}[
  style=vscode-darkplus-python,
  caption={Testy.},
  label=lst:python_code,
  captionpos=b
]
testman1 = TestManager(QuadTree)
testman2 = TestManager(KdTree)
testman1.all_tests()                 # wykonuje wszystkie testy integracyjne
testman2.all_unittest()              # wykonuje wszystkie testy jednostkowe
testman1.contain_point_int()         # wykonuje testy dla punktow int
testman2.contain_point_float()       # wykonuje testy dla punktow float
testman2.search_in_rectangle_int()   # wykonuje testy dla punktow int
testman2.search_in_rectangle_float() # wykonuje testy dla punktow float
\end{lstlisting}

\section{Wizualizacja}
Przykładowe wizualizacje znajdują się w pliku $visualizer/demo.ipynb$.

\section{Porównanie}
Porównanie wydajności struktur QuadTree i KdTree znajduje się w pliku $Comparision.ipynb$, wraz z generacją wykresów oraz otrzymanymi siatkami.

\newpage
\part{Sprawozdanie}
\section{Wstęp teoretyczny}
\subsection{Cel sprawozdania}
Dane są punkty na płaszczyźnie określające prostokąt $P1(x1,y1)$, oraz $P2(x2,y2)$. 

Należy znaleźć zbiór punktów Q ze zbioru spełniających warunki:
\begin{itemize}
    \item $x_1 < q_x < x_2$
    \item $y_1 < q_y < y_2$
\end{itemize}

Sprawozdania ma na celu rozwiązanie problemu przeszukiwania zbioru punktów, w celu znalezienia tych, które należą do zadanego przez nas obszaru. 
Przedstawione zostaną podstawowe informacje o strukturach QuadTree oraz KdTree, a także opis ich implementacji oraz porównanie wydajności dla zróżnicowanych danych wejściowych.

\subsection{QuadTree}
QuadTree jest strukturą danych, która umożliwia przechowywanie punktów w dwuwymiarowej przestrzeni. 
Służy do podziału dwuwymiarowej przestrzeni na mniejsze części, dzieląc je na cztery równe ćwiartki, a następnie podzielone ćwiartki na kolejne cztery ćwiartki, aż do osiągnięcia maksymalnej pojemności węzła.
Węzeł naszego drzewa bedzie prostokątnym obszarem, który będzie reprezentował drzewo czwórkowe, a liście będą również prostokątnymi obszarami, które nie zostały podzielone ze względu na ilość punktów w danym obszarze.
\begin{figure}[H]
  \centering
  \includegraphics[width=0.5\textwidth]{resources/quadtree.png}
  \caption{Przykładowe drzewo QuadTree.}
  \label{fig:quadtree}
\end{figure}

\subsection{KdTree}
KdTree jest strukturą danych będącą drzewem binarnym, która umożliwia przechowywanie punktów w wielowymiarowej przestrzeni.
Służy do podziału wielowymiarowej przestrzeni na mniejsze części, dzieląc ją na dwie części względem punkt mediany dla kolejnych wymiarów, 
a następnie podzielone części na kolejne dwie części względem ich mediany, aż do momentu dotarcia do liścia, który będzie zawierał jeden punkt.
\begin{figure}[H]
  \centering
  \includegraphics[width=0.5\textwidth]{resources/kdtree.jpg}
  \caption{Przykładowe drzewo KdTree.}
  \label{fig:kdtree}
\end{figure}

\section{Opis implementacji}
\subsection{QuadTree}
Strukturę inicjuje się poprzez utworzenie obiektu klasy QuadTree, który przyjmuje listę punktów, które mają zostać dodane do drzewa.
Wtedy w kolejnych węzłach punkty są dzielone na podstawie przynależności do danej ćwiartki i z utworzonego podzbioru tworzony jest kolejny węzeł zawierający należące do niego punkty, 
który powtarza operacje do momentu, w którym ilość punktów nie będzie przekraczać ustalonej wartości $max\_capacity$.

W trakcie wyszukiwania zadanego punktu w drzewie, punkt przechodzi przez kolejne węzły w ten sam sposób jaki byłby dodawany do drzewa, a więc wchodzi do kolejnych węzłów, w których się zawiera, aż do momentu dotarcia do liścia,
w którym następuje sprawdzenie czy punkt znajduje się w liściu.

Podczas wyszukiwania punktów w prostokącie, sprawdzane są wszystkie węzły, które przecinają się z prostokątem, a następnie rekurencyjnie dochodzimy do liści,
w których sprawdzamy czy punkt znajduje się w prostokącie.

Złożoność czasowa wyszukiwania punktu w drzewie wynosi $O(dl)$, gdzie $d$ to głębokość drzewa, a $l$ to ilość liści w drzewie.

\subsection{KdTree}
Strukturę inicjuje się poprzez utworzenie obiektu klasy KdTree, który przyjmuje listę punktów, które mają zostać dodane do drzewa.
Wtedy w kolejnych węzłach punkty są sortowane względem danego wymiaru i wybierana jest mediana, na podstawie której punkty są dzielone na dwie części.
Z utworzonego podzbioru tworzony jest kolejny węzeł, który powtarza operacje dla następnego wymiaru, aż do momentu, w którym węzeł będzie zawierał jeden punkt.

W trakcie wyszukiwania zadanego punktu w drzewie, punkt jest porównywany z osią tworzącą węzeł, i na tej podstawie przechodzi do odpowiedniego węzła,
aż do momentu dotarcia do liścia, w którym następuje sprawdzenie czy punkt znajduje się w liściu.

Podczas wyszukiwania punktów w prostokącie, sprawdzane są wszystkie węzły, które przecinają się z prostokątem, a następnie rekurencyjnie dochodzimy do liści,
w których sprawdzamy czy punkt znajduje się w prostokącie.

Złożoność obliczeniowa utworzenia drzewa KD wynosi $O(kn*logn)$, gdzie $n$ to ilość punktów w drzewie, $k$ to ilość wymiarów. Przy zrównoważonym drzewie złożoność obliczeniowa wyszukiwania wynosi $O(\sqrt{n}+k)$, gdzie $n$ to ilość punktów w drzewie, $k$ to ilość punktów wynikowych.

\section{Porównanie wyników dla różnych danych wejściowych}
Porównania znajdują się w pliku $Comparision.ipynb$, zostały tam przedstawione wykresy oraz opis porównania wydajności struktur dla różnych danych wejściowych.
wykorzystane zostały zbiory punktów wygenerowane przez klasę $CaseGenerator$ w zbiorach od 10000 do 100000 punktów z krokiem 10000 wewnątrz prostokąta o wierzchołkach (0,0), (100,0), (100,100), (0,100).
Porównane zostały czasy inicjalizacji struktury oraz czasy wyszukiwania punktów w strukturze.
\newpage
\subsection{Zbiór punktów o rozkładzie jednorodnym}
Zbiór reprezentujący losowo wygenerowane punkty w przestrzeni dwuwymiarowej należąych do danego prostokąta.
Wyszukujemy punkty znajdujące się w obszarze, który częściowo przecina nasz zbiór
punktów. Jest to przypadek neutralny, ponieważ punkty są równomiernie rozłożone w przestrzeni.

\begin{figure}[H]
  \centering
  \includegraphics[width=0.5\textwidth]{resources/uniform.png}
  \caption{Zbiór punktów o rozkładzie jednorodnym.}
  \label{fig:uniform}
\end{figure}

\begin{figure}[H]
  \centering
  \begin{minipage}{0.495\textwidth}
      \centering
      \includegraphics[width=1\textwidth]{resources/uniform_QuadTree.png}
      \caption{Siatka QuadTree rozkładu jednorodnego.}
      \label{fig:uniform_QuadTree}
  \end{minipage}
  \begin{minipage}{0.495\textwidth}
      \centering
      \includegraphics[width=1\textwidth]{resources/uniform_KdTree.png}
      \caption{Siatka KdTree rozkładu jednorodnego.}
      \label{fig:uniform_KdTree}
  \end{minipage}
\end{figure}

\begin{table}[H]
\centering
\begin{tabular}{lrrrrr}
  \toprule
   & \multicolumn{5}{c}{Rozkład jednorodny} \\
   &  & \multicolumn{2}{r}{Czas konstrukcji [s]} & \multicolumn{2}{r}{Czas przeszukiwania [s]} \\
   & Liczba punktów & KdTree & QuadTree & KdTree & QuadTree \\
  \midrule
1 & 10000 & 0.525953 & 0.603661 & 0.006965 & 0.017502 \\
2 & 20000 & 0.879578 & 1.301307 & 0.015709 & 0.031569 \\
3 & 30000 & 1.833377 & 2.940357 & 0.035963 & 0.055741 \\
4 & 40000 & 3.320225 & 3.408814 & 0.033606 & 0.052383 \\
5 & 50000 & 4.035366 & 4.130799 & 0.036009 & 0.065693 \\
6 & 60000 & 5.321494 & 5.128195 & 0.046706 & 0.071691 \\
7 & 70000 & 6.319651 & 6.413196 & 0.056525 & 0.109037 \\
8 & 80000 & 6.937868 & 7.912826 & 0.025324 & 0.065647 \\
9 & 90000 & 3.682173 & 3.769052 & 0.026852 & 0.082187 \\
10 & 100000 & 7.567008 & 8.679212 & 0.055804 & 0.140044 \\
  \bottomrule
\end{tabular}
\caption{Wyniki pomiarów porównujące wydajność QuadTree i KdTree dla zbioru rozkładu jednorodnego.}
\label{tab:uniform_time}
\end{table}

\begin{figure}[H]
  \centering
  \includegraphics[width=1\textwidth]{resources/uniform_graph.png}
  \caption{Wykres porównujący wydajność QuadTree i KdTree dla zbioru punktów o rozkładzie jednorodnym.}
  \label{fig:uniform_graph}
\end{figure}

Na powyższym wykresie widać, że KdTree jest szybszye zarówno podczs konstrukcji, jak i przeszukiwania. Niestabilność widoczna na wykresie konstrukcji może zależeć od losowości tworzenia zbioru.

\newpage
\subsection{Zbiór punktów o rozkładzie normalnym}
Zbiór reprezentujący punkty wygenerowane zgodnie z rozkładem normalnym w przestrzeni dwuwymiarowej.
Oznacza to, że punkty są bardziej skupione w środku prostokąta, a na brzegach jest ich mniej.
Przeszukiwanym prostokątem jest prostokąt o wierzchołkach (25,25), (75,25), (75,75), (25,75).

\begin{figure}[H]
  \centering
  \includegraphics[width=0.5\textwidth]{resources/normal.png}
  \caption{Zbiór punktów o rozkładzie normalnym.}
  \label{fig:normal}
\end{figure}

\begin{figure}[H]
  \centering
  \begin{minipage}{0.495\textwidth}
      \centering
      \includegraphics[width=1\textwidth]{resources/normal_QuadTree.png}
      \caption{Siatka QuadTree dla rozkładu normalnego.}
      \label{fig:normal_QuadTree}
  \end{minipage}
  \begin{minipage}{0.495\textwidth}
      \centering
      \includegraphics[width=1\textwidth]{resources/normal_KdTree.png}
      \caption{Siatka KdTree dla rozkładu normalnego.}
      \label{fig:normal_KdTree}
  \end{minipage}
\end{figure}

\begin{table}[H]
\centering
\begin{tabular}{lrrrrr}
  \toprule
   & \multicolumn{5}{c}{Rozkład normalny} \\
   &  & \multicolumn{2}{r}{Czas konstrukcji [s]} & \multicolumn{2}{r}{Czas przeszukiwania [s]} \\
   & Liczba punktów & KdTree & QuadTree & KdTree & QuadTree \\
  \midrule
1 & 10000 & 0.739546 & 0.952264 & 0.027823 & 0.037308 \\
2 & 20000 & 1.707641 & 1.774976 & 0.042721 & 0.078259 \\
3 & 30000 & 2.229701 & 2.539679 & 0.042665 & 0.088242 \\
4 & 40000 & 3.394858 & 3.609045 & 0.085345 & 0.124107 \\
5 & 50000 & 4.173224 & 4.534599 & 0.063369 & 0.141578 \\
6 & 60000 & 4.914829 & 5.526659 & 0.079745 & 0.199600 \\
7 & 70000 & 6.192708 & 6.572183 & 0.091050 & 0.247608 \\
8 & 80000 & 6.833023 & 7.734797 & 0.100284 & 0.349896 \\
9 & 90000 & 7.688269 & 7.967488 & 0.103521 & 0.321787 \\
10 & 100000 & 9.013417 & 9.272826 & 0.113198 & 0.334062 \\
  \bottomrule
  \end{tabular}
\caption{Wyniki pomiarów porównujące wydajność QuadTree i KdTree dla rozkładu normalnego.}
\label{tab:normal_time}
\end{table}  

\begin{figure}[H]
  \centering
  \includegraphics[width=1\textwidth]{resources/normal_graph.png}
  \caption{Wykres porównujący wydajność QuadTree i KdTree dla zbioru punktów o rozkładzie normalnym.}
  \label{fig:normal_graph}
\end{figure}

Na powyższym wykresie widać, że tak jak poprzednio czas inicjalizacji struktur jest niemal identyczny, ale poczas przeszukiwania KdTree radzi sobie znacznie lepiej względem QuadTree.

\newpage
\subsection{Zbiór punktów o rozkładzie 'siatka'}
Rozkład punktów przypomina siatkę, ponieważ punkty są równomiernie rozłożone wzdłuż osi X i Y wewnątrz zadanego prostokąta.
Przeszukiwanym prostokąt jest prostokąt o wierzchołkach (25,25), (75,25), (75,75), (25,75).
Zbiór ten jest problematyczny, ponieważ może zawierać wiele punktów na osi podziału, co może spowodować, że drzewo będzie niezrównoważone.

\begin{figure}[H]
  \centering
  \includegraphics[width=0.5\textwidth]{resources/grid.png}
  \caption{Zbiór punktów o rozkładzie "siatka".}
  \label{fig:grid}
\end{figure}

\begin{figure}[H]
  \centering
  \begin{minipage}{0.495\textwidth}
      \centering
      \includegraphics[width=1\textwidth]{resources/grid_QuadTree.png}
      \caption{Siatka QuadTree dla rozkładu "siatka".}
      \label{fig:grid_QuadTree}
  \end{minipage}
  \begin{minipage}{0.495\textwidth}
      \centering
      \includegraphics[width=1\textwidth]{resources/grid_KdTree.png}
      \caption{Siatka KdTree dla rozkładu "siatka".}
      \label{fig:grid_KdTree}
  \end{minipage}
\end{figure}

\begin{table}[H]
\centering
\begin{tabular}{lrrrrr}
  \toprule
   & \multicolumn{5}{c}{Rozkład siatka} \\
   &  & \multicolumn{2}{r}{Czas konstrukcji [s]} & \multicolumn{2}{r}{Czas przeszukiwania [s]} \\
   & Liczba punktów & KdTree & QuadTree & KdTree & QuadTree \\
  \midrule
1 & 10000 & 0.760563 & 0.804475 & 0.017787 & 0.020623 \\
2 & 20000 & 1.191172 & 1.315219 & 0.027098 & 0.030674 \\
3 & 30000 & 1.830970 & 2.464700 & 0.027581 & 0.038512 \\
4 & 40000 & 2.300369 & 3.230727 & 0.055203 & 0.071101 \\
5 & 50000 & 3.731767 & 4.215484 & 0.038001 & 0.068557 \\
6 & 60000 & 4.130582 & 5.627054 & 0.046119 & 0.053191 \\
7 & 70000 & 4.493137 & 6.378847 & 0.057497 & 0.077872 \\
8 & 80000 & 5.352753 & 7.442259 & 0.047987 & 0.083077 \\
9 & 90000 & 5.616267 & 8.432021 & 0.049193 & 0.079609 \\
10 & 100000 & 6.655318 & 9.113047 & 0.062163 & 0.091143 \\
  \bottomrule
  \end{tabular}
\caption{Wyniki pomiarów porównujące wydajność QuadTree i KdTree dla rozkładu "siatka".}
\label{tab:grid_time}
\end{table}

\begin{figure}[H]
  \centering
  \includegraphics[width=1\textwidth]{resources/grid_graph.png}
  \caption{Wykres porównujący wydajność QuadTree i KdTree dla zbioru punktów o rozkładzie "siatka".}
  \label{fig:grid_graph}
\end{figure}
TODO
W tym przypadku widać zbliżony czas zarówno inicjalizacji struktur, jaki i przeszukiwania do połowy zakresu porównania. Jedynie przy większej ilości punktów KdTree prezentuje się lepiej.

\newpage
\subsection{Zbiór punktów o rozkładzie klastrowym}
Ten przypadek reprezentuje trzy grupy mocno skupionych punktów w przestrzeni dwuwymiarowej.
Ze względu na niezrównoważone wybory prostokąta zedecydowano się na podział tego problemu na dwa przypadki, aby zobaczyć jak struktury zachowują się w odmiennych sytuacjach.

\begin{figure}[H]
  \centering
  \includegraphics[width=0.5\textwidth]{resources/cluster.png}
  \caption{Zbiór punktów o rozkładzie klastrowym.}
  \label{fig:cluster}
\end{figure}

\subsubsection{Z małą ilością punktów (1)}
Dla tego przypadku obasz zawiera nieznaczne fragmenty dwóch skupisk punktów, i dominuje znaczna pusta przestrzeń,

\begin{figure}[H]
  \centering
  \begin{minipage}{0.495\textwidth}
      \centering
      \includegraphics[width=1\textwidth]{resources/cluster_QuadTree_1.png}
      \caption{Siatka QuadTree dla rozkładu klaster (1).}
      \label{fig:cluster_QuadTree_1}
  \end{minipage}
  \begin{minipage}{0.495\textwidth}
      \centering
      \includegraphics[width=1\textwidth]{resources/cluster_KdTree_1.png}
      \caption{Siatka KdTree dla rozkładu klaster (1).}
      \label{fig:cluster_KdTree_1}
  \end{minipage}
\end{figure}

\begin{table}[H]
\centering
\begin{tabular}{lrrrrr}
  \toprule
   & \multicolumn{5}{c}{Rozkład klastrowy (1)} \\
   &  & \multicolumn{2}{r}{Czas konstrukcji [s]} & \multicolumn{2}{r}{Czas przeszukiwania [s]} \\
   & Liczba punktów & KdTree & QuadTree & KdTree & QuadTree \\
  \midrule
1 & 10000 & 0.744485 & 1.146938 & 0.019429 & 0.004075 \\
2 & 20000 & 1.384678 & 1.626412 & 0.045429 & 0.007739 \\
3 & 30000 & 2.832320 & 2.930801 & 0.034926 & 0.008536 \\
4 & 40000 & 3.370394 & 4.088355 & 0.044638 & 0.009340 \\
5 & 50000 & 4.737663 & 3.483118 & 0.026201 & 0.008898 \\
6 & 60000 & 6.363855 & 6.455460 & 0.054979 & 0.011443 \\
7 & 70000 & 5.795496 & 6.191663 & 0.086012 & 0.012112 \\
8 & 80000 & 6.720413 & 6.898166 & 0.058796 & 0.010809 \\
9 & 90000 & 7.459068 & 7.749592 & 0.061746 & 0.014384 \\
10 & 100000 & 13.345561 & 6.145183 & 0.054499 & 0.008764 \\
  \bottomrule
  \end{tabular}
\caption{Wyniki pomiarów porównujące wydajność QuadTree i KdTree dla rozkładu klaster (1).}
\label{tab:cluster_time_1}
\end{table}

\begin{figure}[H]
  \centering
  \includegraphics[width=1\textwidth]{resources/cluster_graph_1.png}
  \caption{Wykres porównujący wydajność QuadTree i KdTree dla rozkładu klaster (1).}
  \label{fig:cluster_graph_1}
\end{figure}

Czas konstrukcji drzew jest niemalże identyczny dla tej samej liczby punktów, jedynie odchylenia pojawiają się przy największym zbiorze, co można uznać za błąd pomiarowy.

Podczas przeszukiwania QuadTree osiągało zbliżone czasy, mimo większej ilości punktów, co oznacza, że sprawniej radziło sobie z przechodzeniem po odpowiednich węzłach.

\newpage
\subsubsection{Z dużą ilością punktów (2)}
Dla tego przypadku przeszukujemy obszar zawierający znaczne fragmenty dwóch skupisk punktów.

\begin{figure}[H]
  \centering
  \begin{minipage}{0.495\textwidth}
      \centering
      \includegraphics[width=1\textwidth]{resources/cluster_QuadTree_2.png}
      \caption{Siatka QuadTree dla rozkładu klastrowego (2).}
      \label{fig:cluster_QuadTree_2}
  \end{minipage}
  \begin{minipage}{0.495\textwidth}
      \centering
      \includegraphics[width=1\textwidth]{resources/cluster_KdTree_2.png}
      \caption{Siatka KdTree dla rozkładu klastrowego (2).}
      \label{fig:cluster_KdTree_2}
  \end{minipage}
\end{figure}

\begin{table}[H]
\centering
\begin{tabular}{lrrrrr}
  \toprule
   & \multicolumn{5}{c}{Rozkład klastrowy (2)} \\
   &  & \multicolumn{2}{r}{Czas konstrukcji [s]} & \multicolumn{2}{r}{Czas przeszukiwania [s]} \\
   & Liczba punktów & KdTree & QuadTree & KdTree & QuadTree \\
  \midrule
1 & 10000 & 0.332947 & 0.379944 & 0.011154 & 0.009497 \\
2 & 20000 & 0.796904 & 0.860786 & 0.037727 & 0.051893 \\
3 & 30000 & 1.849791 & 1.823151 & 0.023719 & 0.033841 \\
4 & 40000 & 1.731005 & 1.727538 & 0.019790 & 0.028582 \\
5 & 50000 & 2.212551 & 2.230030 & 0.020901 & 0.036624 \\
6 & 60000 & 2.680116 & 2.618285 & 0.037243 & 0.091985 \\
7 & 70000 & 3.694794 & 3.129360 & 0.095646 & 0.086734 \\
8 & 80000 & 3.436740 & 3.804738 & 0.036856 & 0.069029 \\
9 & 90000 & 4.169493 & 4.244927 & 0.033543 & 0.078159 \\
10 & 100000 & 4.692992 & 4.678534 & 0.033104 & 0.101984 \\
  \bottomrule
  \end{tabular}
\caption{Wyniki pomiarów porównujące wydajność QuadTree i KdTree dla rozkładu klastrowego (2).}
\label{tab:cluster_time_2}
\end{table}

\begin{figure}[H]
  \centering
  \includegraphics[width=1\textwidth]{resources/cluster_graph_2.png}
  \caption{Wykres porównujący wydajność QuadTree i KdTree dla rozkładu klastrowego (2).}
  \label{fig:cluster_graph_2}
\end{figure}

W tym przypadku KdTree potrzebowało zdecydowanie więcej czasu na zbudownie pełnego drzewa, jednakże przy przeszukiwaniu zadanych obszarów, to ono poradziło sobie lepiej.

\newpage
\subsection{Zbiór punktów o rozkładzie z punktami odstającym}
W tym przypadku mamy podobną sytuację co w rozkładzie normalnym, jednakże centrum prostokąta jest znacznie bardziej zagęszczone, a pojedyncze punkty znajdują się na obrzeżach prostokąta.

Również i tutaj zdecydowano się na podział tego problemu na dwa przypadki, aby zobaczyć jak struktury zachowują się w odmiennych sytuacjach.

\begin{figure}[H]
  \centering
  \includegraphics[width=0.5\textwidth]{resources/outlier.png}
  \caption{Zbiór punktów o rozkładzie z punktami odstającymi.}
  \label{fig:outlier}
\end{figure}

\subsubsection{Z małą ilością punktów}
W tej sytuacji przeszukiwany prostokąt nie zawiera centralnej grupy punktów, a jedynie wychwytuje pojedyncze punkty odstające.

\begin{figure}[H]
  \centering
  \begin{minipage}{0.495\textwidth}
      \centering
      \includegraphics[width=1\textwidth]{resources/outlier_QuadTree_1.png}
      \caption{Siatka QuadTree dla rozkładu odstającego (1).}
      \label{fig:outlier_QuadTree_1}
  \end{minipage}
  \begin{minipage}{0.495\textwidth}
      \centering
      \includegraphics[width=1\textwidth]{resources/outlier_KdTree_1.png}
      \caption{Siatka KdTree dla rozkładu odstającego  (1).}
      \label{fig:outlier_KdTree_1}
  \end{minipage}
\end{figure}

\begin{table}[H]
\centering
\begin{tabular}{lrrrrr}
  \toprule
   & \multicolumn{5}{c}{Rozkład z odstającymi (1)} \\
   &  & \multicolumn{2}{r}{Czas konstrukcji [s]} & \multicolumn{2}{r}{Czas przeszukiwania [s]} \\
   & Liczba punktów & KdTree & QuadTree & KdTree & QuadTree \\
  \midrule
 1 & 10000 & 0.489375 & 0.524964 & 0.004784 & 0.000502 \\
2 & 20000 & 1.154447 & 1.115454 & 0.014153 & 0.000350 \\
3 & 30000 & 1.546494 & 1.476078 & 0.009427 & 0.000544 \\
4 & 40000 & 1.533275 & 1.927339 & 0.014799 & 0.000809 \\
5 & 50000 & 2.083945 & 2.201441 & 0.010279 & 0.000359 \\
6 & 60000 & 2.967560 & 2.735626 & 0.022038 & 0.000294 \\
7 & 70000 & 3.082076 & 3.363270 & 0.013432 & 0.000267 \\
8 & 80000 & 3.217827 & 5.419607 & 0.018007 & 0.000354 \\
9 & 90000 & 4.329930 & 4.179824 & 0.020457 & 0.000221 \\
10 & 100000 & 4.419229 & 4.760538 & 0.018829 & 0.000348 \\
  \bottomrule
  \end{tabular}
\caption{Wyniki pomiarów porównujące wydajność QuadTree i KdTree rozkładu odstającego (1).}
\label{tab:outlier_time_1}
\end{table}

\begin{figure}[H]
  \centering
  \includegraphics[width=1\textwidth]{resources/outlier_graph_1.png}
  \caption{Wykres porównujący wydajność QuadTree i KdTree dla rozkładu odstającego (1).}
  \label{fig:outlier_graph_1}
\end{figure}

Budowa obu drzew zajmuje mniej więcej tyle samo czasu z małą przewagą dla struktury KdTree w przypadku zbioru o liczebności 8000 - może to wynikać z wygenerowania wyjątkowo niewygodnego zbioru dla budowy struktury QuadTree). Czas przeszukiwania, jednak znacznie przeważa na korzyść drzewa ćwiartkowego.

\newpage
\subsubsection{Z dużą ilością punktów}
W tej sytuacji przeszukiwany obszar zawiera znaczną część centralnej grupy punktów, a także pojedyncze punkty odstające.

\begin{figure}[H]
  \centering
  \begin{minipage}{0.495\textwidth}
      \centering
      \includegraphics[width=1\textwidth]{resources/outlier_QuadTree_2.png}
      \caption{Siatka QuadTree dla rozkładu odstającego (2).}
      \label{fig:outlier_QuadTree_2}
  \end{minipage}
  \begin{minipage}{0.495\textwidth}
      \centering
      \includegraphics[width=1\textwidth]{resources/outlier_KdTree_2.png}
      \caption{Siatka KdTree dla rozkładu odstającego (2).}
      \label{fig:outlier_KdTree_2}
  \end{minipage}
\end{figure}

\begin{table}[H]
\centering
\begin{tabular}{lrrrrr}
  \toprule
   & \multicolumn{5}{c}{Rozkład z odstającymi (2)} \\
   &  & \multicolumn{2}{r}{Czas konstrukcji [s]} & \multicolumn{2}{r}{Czas przeszukiwania [s]} \\
   & Liczba punktów & KdTree & QuadTree & KdTree & QuadTree \\
  \midrule
1 & 10000 & 0.392502 & 0.392262 & 0.019904 & 0.035270 \\
2 & 20000 & 0.725716 & 0.889906 & 0.014218 & 0.022862 \\
3 & 30000 & 1.438910 & 1.690897 & 0.015602 & 0.028825 \\
4 & 40000 & 1.543269 & 1.709909 & 0.036825 & 0.069247 \\
5 & 50000 & 3.925621 & 3.695152 & 0.042901 & 0.101671 \\
6 & 60000 & 5.170620 & 6.477736 & 0.025804 & 0.074978 \\
7 & 70000 & 3.204646 & 3.253412 & 0.032528 & 0.075253 \\
8 & 80000 & 3.257927 & 3.435762 & 0.034024 & 0.090642 \\
9 & 90000 & 3.725386 & 3.910516 & 0.039311 & 0.109010 \\
10 & 100000 & 4.184204 & 4.359409 & 0.041051 & 0.125713 \\
  \bottomrule
  \end{tabular}
\caption{Wyniki pomiarów porównujące wydajność QuadTree i KdTree dla rozkładu odstającego (2).}
\label{tab:outlier_time_2}
\end{table}  

\begin{figure}[H]
  \centering
  \includegraphics[width=1\textwidth]{resources/outlier_graph_2.png}
  \caption{Wykres porównujący wydajność QuadTree i KdTree dla rozkładu odstającego (2).}
  \label{fig:outlier_graph_2}
\end{figure}

Z wykresu możemy wywnioskować, że czasy budowy obu drzew nie różnią się zbytnio od siebie. Widać wartość odstającą dla zbioru 9, co potwierdza wrażliwość obu drzew na struktury danych. Czas przeszukiwania natomiast jest szybszy przy użyciu Kd-drzewa. Wykres przypomina nieco wykresy z początkowych podpunktów.

\newpage
\subsection{Zbiór punktów o rozkładzie krzyżowym}
W tym przypadku mamy podobną sytuację co w rozkładzie "siatka", jednakże punkty są równomiernie rozłożone wzdłuż osi symetrii prostokąta, a więc znacznie więcej punktów jest współliniowych.

Przeszukiwany obszar zawiera fragmenty obu prostych, co powoduje, że drzewo będzie musiało pokonać znacznie większą głębokość, aby znaleźć wszystkie punkty.

\begin{figure}[H]
  \centering
  \includegraphics[width=0.5\textwidth]{resources/cross.png}
  \caption{Zbiór punktów o rozkładzie krzyżowym.}
  \label{fig:cross}
\end{figure}

\begin{figure}[H]
  \centering
  \begin{minipage}{0.495\textwidth}
      \centering
      \includegraphics[width=1\textwidth]{resources/cross_QuadTree.png}
      \caption{Siatka QuadTree dla rozkładu krzyżowego.}
      \label{fig:cross_QuadTree}
  \end{minipage}
  \begin{minipage}{0.495\textwidth}
      \centering
      \includegraphics[width=1\textwidth]{resources/cross_KdTree.png}
      \caption{Siatka KdTree dla rozkładu krzyżowego.}
      \label{fig:cross_KdTree}
  \end{minipage}
\end{figure}

\begin{table}[H]
\centering
\begin{tabular}{lrrrrr}
  \toprule
   & \multicolumn{5}{c}{Rozkład krzyż} \\
   &  & \multicolumn{2}{r}{Czas konstrukcji [s]} & \multicolumn{2}{r}{Czas przeszukiwania [s]} \\
   & Liczba punktów & KdTree & QuadTree & KdTree & QuadTree \\
  \midrule
 1 & 10000 & 0.352320 & 0.828095 & 0.019195 & 0.010147 \\
2 & 20000 & 0.932730 & 1.604570 & 0.027632 & 0.013407 \\
3 & 30000 & 1.251809 & 4.130071 & 0.056319 & 0.048069 \\
4 & 40000 & 2.510517 & 6.102843 & 0.045348 & 0.029465 \\
5 & 50000 & 3.323393 & 7.474479 & 0.025906 & 0.031376 \\
6 & 60000 & 1.975971 & 5.418630 & 0.033230 & 0.042832 \\
7 & 70000 & 2.326260 & 4.737657 & 0.042741 & 0.037731 \\
8 & 80000 & 2.736304 & 5.495954 & 0.038266 & 0.049964 \\
9 & 90000 & 3.156827 & 6.273638 & 0.044632 & 0.052923 \\
10 & 100000 & 3.848184 & 9.214811 & 0.054329 & 0.067162 \\
  \bottomrule
  \end{tabular}
\caption{Wyniki pomiarów porównujące wydajność QuadTree i KdTree dla rozkładu krzyżowego.}
\label{tab:cross_time}
\end{table}

\begin{figure}[H]
  \centering
  \includegraphics[width=1\textwidth]{resources/cross_graph.png}
  \caption{Wykres porównujący wydajność QuadTree i KdTree dla rozkładu krzyżowego.}
  \label{fig:cross_graph}
\end{figure}

Czas budowy QuadTree jest znacznie szybszy w tym przypadku, warto zauważyć, że czasy konstrukcji obu struktur w tym przypadku są funkcją liniową. Czas przeszukiwania jest również lepszy na korzyść QuadTre, dla dużej ilości punktów KdTree osiąga dużo większe wartości.
\newpage
\subsection{Zbiór punktów o rozkładzie na bokach prostokąta}
Sytuacja podobna do poprzedniej, jednakże zagęszczamy problem w większej ilości miejsc.

\begin{figure}[H]
  \centering
  \includegraphics[width=0.5\textwidth]{resources/rectangle.png}
  \caption{Zbiór punktów o rozkładzie prostokątnym.}
  \label{fig:rectangle}
\end{figure}

\begin{figure}[H]
  \centering
  \begin{minipage}{0.495\textwidth}
      \centering
      \includegraphics[width=1\textwidth]{resources/rectangle_QuadTree.png}
      \caption{Siatka QuadTree dla zbioru punktów o rozkładzie prostokątnym.}
      \label{fig:rectangle_QuadTree}
  \end{minipage}
  \begin{minipage}{0.495\textwidth}
      \centering
      \includegraphics[width=1\textwidth]{resources/rectangle_KdTree.png}
      \caption{Siatka KdTree dla zbioru punktów o rozkładzie prostokątnym.}
      \label{fig:rectangle_KdTree}
  \end{minipage}
\end{figure}

\begin{table}[H]
\centering
\begin{tabular}{lrrrrr}
  \toprule
   & \multicolumn{5}{c}{Rozkład prostokąt} \\
   &  & \multicolumn{2}{r}{Czas konstrukcji [s]} & \multicolumn{2}{r}{Czas przeszukiwania [s]} \\
   & Liczba punktów & KdTree & QuadTree & KdTree & QuadTree \\
  \midrule
 1 & 10000 & 0.375075 & 0.649978 & 0.007469 & 0.002012 \\
2 & 20000 & 0.610409 & 1.282686 & 0.005383 & 0.003395 \\
3 & 30000 & 0.946753 & 2.131414 & 0.017567 & 0.015938 \\
4 & 40000 & 1.923439 & 3.270247 & 0.012884 & 0.010967 \\
5 & 50000 & 3.759927 & 7.306431 & 0.017963 & 0.015527 \\
6 & 60000 & 4.311115 & 8.518162 & 0.028830 & 0.021768 \\
7 & 70000 & 3.606635 & 6.099763 & 0.025063 & 0.029072 \\
8 & 80000 & 7.144494 & 12.368523 & 0.017309 & 0.018718 \\
9 & 90000 & 3.574068 & 10.166259 & 0.022601 & 0.031538 \\
10 & 100000 & 7.407704 & 12.718501 & 0.022318 & 0.026166 \\
  \bottomrule
  \end{tabular}
\caption{Wyniki pomiarów porównujące wydajność QuadTree i KdTree dla zbioru punktów o rozkładzie na bokach prostokąta.}
\label{tab:rectangle_time}
\end{table}

\begin{figure}[H]
  \centering
  \includegraphics[width=1\textwidth]{resources/rectangle_graph.png}
  \caption{Wykres porównujący wydajność QuadTree i KdTree dla zbioru punktów o rozkładzie prostokątnym.}
  \label{fig:rectangle_graph}
\end{figure}
Czas konstrukcji w tym przypadku jest większy dla QuadTree, widać również skoki wartości co udowadnia, że oba drzewa są wrażliwe na strukturę danych. Czas przeszukiwania natomiast jest względnie podobny z jedną większą różnicą przy zbiorze z 9000 punktów.


\newpage
\subsection{Porównanie efektywności QuadTree dla różnych wartości max\_capacity}
Przeprowadzono testy dla różnych wartości max\_capacity, aby sprawdzić jak wpływa ona na czas konstrukcji i przeszukiwania QuadTree.

Porównane zostały operacje dla zbioru o rozkładzie normalnym liczącego 5000 punktów.
Natomiast wartości capacity zawierały się w przedziale od 1 do 1000.

\begin{figure}[H]
  \centering
  \includegraphics[width=0.5\textwidth]{resources/capacity_graph.png}
  \caption{Wykres porównujący wydajność QuadTree dla różnych wartości max\_capacity.}
  \label{fig:capacity_graph}
\end{figure}

Czas konstrukcji dla max\_capacity mniejszych niż 200 gwałtownie spada, następnie wykres jest bardziej płaski. Wynika to z faktu, że dla małych wartości max\_capacity, drzewo jest znacznie głębsze, a więc musi wykonać znacznie więcej operacji, aby znaleźć odpowiednią komórkę. Dla większych wartości max\_capacity, drzewo jest znacznie płytsze, a więc czas konstrukcji jest znacznie krótszy.

Odwrotną sytuację spotykamy przy przeszukiwaniu. Dla małych wartości max\_capacity, drzewo jest w stanie sprawniej operować wyborem potrzebnych węzłów, natomiast dla rosnącej liczby max\_capacity przeszukiwanie staje się przechodzeniem przez listę.

\subsection{Testowanie KdTree dla różnej ilości wymiarów}
Struktura KDTree zapewnia możliwość przechowywania punktów dla różnych wymiarów.
Stąd właśnie i pochodzi nazwa - KD od "k dimensions".

Porównane zostały operacje dla zbioru o rozkładzie jednorodnym liczącego 1000 punktów.
Natomiast wartości wymiarów zawierały się w przedziale od 2 do 50.

\begin{figure}[H]
  \centering
  \includegraphics[width=0.5\textwidth]{resources/dimensions_graph.png}
  \caption{Wykres porównujący wydajność KdTree dla różnych ilości wymiarów.}
  \label{fig:dimensions_graph}
\end{figure}

Z powyższego wykresu widać, że czas konstrukcji i przeszukiwania gwałtownie rośnie, aż do momentu przekroczenia 10 wymiarów.
Po tym momencie czas przeszukiwania zwalnia, jednakże mimo zastosowania wartości średniej z 3 pomiarów, wciąż widać znaczne niestablne wartości.
Jedną z przyczyn jest losowe generowanie punktów, które może powodować, że w niektórych przypadkach punkty będą się znajdować w jednym obszarze, a w innych w zupełnie innym, jednakże 
można zauważyć pewnego rodzaju trend rosnący. 

Czyli widzimy, że ilość wymiarów wpływa wprost na czas przeszukiwania. I dla małej ilości punktów przy
dużej ilości wymiarów nie warto używać struktury KDTree.

\section{Podsumowanie}
Na podstawie testów przeprowadzonych dla wyżej przeanalizowanych zbiorów, możemy
stwierdzić, że programy przez nas zaimplementowane działają prawidłowo i poprawnie wyznaczają podzbiór punktów należących do zadanej płaszczyzny. 

Dla każdego z testowanych przypadków, czas konstruowania struktur był podobny, z wyłaczeniem przypadku krzyżowego. 

Jednak dla ważnego konspektu jakim jest wyszukiwanie punktów można określić, że dla zbiorów gęsto oraz średnio usianych, takich jak rozkłady jednolite, normalne, czy zawierające klastry, to KdTree będzie mocniejszym wyborem. 

Sytuacja ma się z goła odmiennie dla zbiorów rzadkich oraz, gdy wiele punktów jest współliniowych,to drzewo ćwiartkowe wiedzie swój prym. Dzięki swojej strukturze, szybciej odcina puste węzły i zapewnia lepsze czasy.

Mimo wszystko, gdy rozkład z jakim będziemy mieli do czynienia jest nieznany to lepszym wyborem będzie drzewo Kd.

\newpage
\section{Bibliografia}
Implementacja poszczególnych struktur danych:
\begin{itemize}
  \item QuadTree - Weronika Wojtas
  \item KdTree - Radosław Rolka
\end{itemize}

Źródła i inspiracje wykorzystane przy tworzeniu projektu:
\begin{itemize}
  \item Wykłady z Algorytmów Geometrycznych, prowadzone przez dr inż. Barbarę Głut, na 3 semestrze Informatyki AGH WI.
  \item \url{https://github.com/aghbit/Algorytmy-Geometryczne}
  \item \url{https://en.wikipedia.org/wiki/Quadtree}
  \item \url{https://en.wikipedia.org/wiki/K-d_tree}
  \item \url{https://en.wikipedia.org/wiki/Nearest_neighbor_search}
  \item \url{https://en.wikipedia.org/wiki/Range_searching}
  \item \url{https://www.agh.edu.pl/o-agh/multimedia/znak-graficzny-agh/}
  \item \url{https://github.com/Goader/KDTree_QuadTree/tree/main} (przypadki testowe)
\end{itemize}

\end{document}